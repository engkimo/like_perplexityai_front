"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),\n/* harmony export */   InternalStreamableUIClient: () => (/* binding */ InternalStreamableUIClient),\n/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),\n/* harmony export */   useAIState: () => (/* binding */ useAIState),\n/* harmony export */   useActions: () => (/* binding */ useActions),\n/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),\n/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),\n/* harmony export */   useUIState: () => (/* binding */ useUIState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsondiffpatch */ \"(ssr)/./node_modules/jsondiffpatch/lib/index.js\");\n/* __next_internal_client_entry_do_not_use__ InternalAIProvider,InternalStreamableUIClient,readStreamableValue,useAIState,useActions,useStreamableValue,useSyncUIState,useUIState auto */ // rsc/shared-client/streamable.tsx\n\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/shared-client/streamable.tsx\n\nfunction hasReadableValueSignature(value) {\n    return !!(value && typeof value === \"object\" && \"type\" in value && value.type === STREAMABLE_VALUE_TYPE);\n}\nfunction assertStreamableValue(value) {\n    if (!hasReadableValueSignature(value)) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n}\nfunction isStreamableValue(value) {\n    const hasSignature = hasReadableValueSignature(value);\n    if (!hasSignature && typeof value !== \"undefined\") {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return hasSignature;\n}\nfunction readStreamableValue(streamableValue) {\n    assertStreamableValue(streamableValue);\n    return {\n        [Symbol.asyncIterator] () {\n            let row = streamableValue;\n            let curr = row.curr;\n            let done = false;\n            let initial = true;\n            return {\n                async next () {\n                    if (done) return {\n                        value: curr,\n                        done: true\n                    };\n                    row = await row;\n                    if (typeof row.error !== \"undefined\") {\n                        throw row.error;\n                    }\n                    if (\"curr\" in row || row.diff) {\n                        if (row.diff) {\n                            switch(row.diff[0]){\n                                case 0:\n                                    if (typeof curr !== \"string\") {\n                                        throw new Error(\"Invalid patch: can only append to string types. This is a bug in the AI SDK.\");\n                                    } else {\n                                        curr = curr + row.diff[1];\n                                    }\n                                    break;\n                                case 1:\n                                    curr = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                                        children: [\n                                            curr,\n                                            row.diff[1]\n                                        ]\n                                    });\n                                    break;\n                            }\n                        } else {\n                            curr = row.curr;\n                        }\n                        if (!row.next) {\n                            done = true;\n                            return {\n                                value: curr,\n                                done: false\n                            };\n                        }\n                    }\n                    if (!row.next) {\n                        return {\n                            value: curr,\n                            done: true\n                        };\n                    }\n                    row = row.next;\n                    if (initial) {\n                        initial = false;\n                        if (typeof curr === \"undefined\") {\n                            return this.next();\n                        }\n                    }\n                    return {\n                        value: curr,\n                        done: false\n                    };\n                }\n            };\n        }\n    };\n}\nfunction useStreamableValue(streamableValue) {\n    const [curr, setCurr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.curr : void 0);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.error : void 0);\n    const [pending, setPending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? !!streamableValue.next : false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!isStreamableValue(streamableValue)) return;\n        let cancelled = false;\n        const iterator = readStreamableValue(streamableValue);\n        if (streamableValue.next) {\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                if (cancelled) return;\n                setPending(true);\n            });\n        }\n        (async ()=>{\n            try {\n                for await (const value of iterator){\n                    if (cancelled) return;\n                    (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                        if (cancelled) return;\n                        setCurr(value);\n                    });\n                }\n            } catch (e) {\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setError(e);\n                });\n            } finally{\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setPending(false);\n                });\n            }\n        })();\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        streamableValue\n    ]);\n    return [\n        curr,\n        error,\n        pending\n    ];\n}\n// rsc/shared-client/context.tsx\n\n\n// rsc/utils.tsx\nvar isFunction = (x)=>typeof x === \"function\";\n// rsc/shared-client/context.tsx\n\nvar InternalUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalAIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar InternalActionProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalSyncUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction InternalAIProvider({ children, initialUIState, initialAIState, initialAIStatePatch, wrappedActions, wrappedSyncUIState }) {\n    if (!(\"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2))))) {\n        throw new Error(\"Unsupported React version.\");\n    }\n    const uiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialUIState);\n    const setUIState = uiState[1];\n    const resolvedInitialAIStatePatch = initialAIStatePatch ? react__WEBPACK_IMPORTED_MODULE_0__.use(initialAIStatePatch) : void 0;\n    initialAIState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (resolvedInitialAIStatePatch) {\n            return jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(initialAIState), resolvedInitialAIStatePatch);\n        }\n        return initialAIState;\n    }, [\n        initialAIState,\n        resolvedInitialAIStatePatch\n    ]);\n    const aiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialAIState);\n    const setAIState = aiState[1];\n    const aiStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(aiState[0]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        aiStateRef.current = aiState[0];\n    }, [\n        aiState[0]\n    ]);\n    const clientWrappedActions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.fromEntries(Object.entries(wrappedActions).map(([key, action])=>[\n                key,\n                async (...args)=>{\n                    const aiStateSnapshot = aiStateRef.current;\n                    const [aiStateDelta, result] = await action(aiStateSnapshot, ...args);\n                    (async ()=>{\n                        const delta = await aiStateDelta;\n                        if (delta !== void 0) {\n                            aiState[1](jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta));\n                        }\n                    })();\n                    return result;\n                }\n            ])), [\n        wrappedActions\n    ]);\n    const clientWrappedSyncUIStateAction = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!wrappedSyncUIState) {\n            return ()=>{};\n        }\n        return async ()=>{\n            const aiStateSnapshot = aiStateRef.current;\n            const [aiStateDelta, uiState2] = await wrappedSyncUIState(aiStateSnapshot);\n            if (uiState2 !== void 0) {\n                setUIState(uiState2);\n            }\n            const delta = await aiStateDelta;\n            if (delta !== void 0) {\n                const patchedAiState = jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta);\n                setAIState(patchedAiState);\n            }\n        };\n    }, [\n        wrappedSyncUIState\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalAIStateProvider.Provider, {\n        value: aiState,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalUIStateProvider.Provider, {\n            value: uiState,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalActionProvider.Provider, {\n                value: clientWrappedActions,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalSyncUIStateProvider.Provider, {\n                    value: clientWrappedSyncUIStateAction,\n                    children\n                })\n            })\n        })\n    });\n}\nfunction useUIState() {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalUIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useUIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialUIState` must be provided to `createAI` or `<AI>`\");\n    }\n    return state;\n}\nfunction useAIState(...args) {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalAIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useAIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialAIState` must be provided to `createAI` or `<AI>`\");\n    }\n    if (args.length >= 1 && typeof state[0] !== \"object\") {\n        throw new Error(\"When using `useAIState` with a key, the AI state must be an object.\");\n    }\n    const key = args[0];\n    const setter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(typeof key === \"undefined\" ? state[1] : (newState)=>{\n        if (isFunction(newState)) {\n            return state[1]((s)=>{\n                return {\n                    ...s,\n                    [key]: newState(s[key])\n                };\n            });\n        } else {\n            return state[1]({\n                ...state[0],\n                [key]: newState\n            });\n        }\n    }, [\n        key\n    ]);\n    if (args.length === 0) {\n        return state;\n    } else {\n        return [\n            state[0][args[0]],\n            setter\n        ];\n    }\n}\nfunction useActions() {\n    const actions = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalActionProvider);\n    return actions;\n}\nfunction useSyncUIState() {\n    const syncUIState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalSyncUIStateProvider);\n    if (syncUIState === null) {\n        throw new Error(\"`useSyncUIState` must be used inside an <AI> provider.\");\n    }\n    return syncUIState;\n}\n// rsc/shared-client/client-wrapper.tsx\n\nfunction InternalStreamableUIClient({ s }) {\n    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(s.curr);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(s.error);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let canceled = false;\n        setError(void 0);\n        (async ()=>{\n            try {\n                for await (const v of readStreamableValue(s)){\n                    if (canceled) {\n                        break;\n                    }\n                    setValue(v);\n                }\n            } catch (e) {\n                if (canceled) {\n                    return;\n                }\n                setError(e);\n            }\n        })();\n        return ()=>{\n            canceled = true;\n        };\n    }, [\n        s\n    ]);\n    if (error) {\n        throw error;\n    }\n    return value;\n}\n //# sourceMappingURL=rsc-shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNoYXJlZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUtPOztBQ0xBLElBQU1HLHdCQUF3QkMsT0FBT0MsR0FBQSxDQUFJO0FBQ3pDLElBQU1DLHNDQUFzQyxLQUFLOztBRHlHcEM7QUFqR3BCLFNBQVNHLDBCQUEwQkMsS0FBQTtJQUNqQyxPQUFPLENBQUMsQ0FDTkEsQ0FBQUEsU0FDQSxPQUFPQSxVQUFVLFlBQ2pCLFVBQVVBLFNBQ1ZBLE1BQU1DLElBQUEsS0FBU1IscUJBQUE7QUFFbkI7QUFFQSxTQUFTUyxzQkFDUEYsS0FBQTtJQUVBLElBQUksQ0FBQ0QsMEJBQTBCQyxRQUFRO1FBQ3JDLE1BQU0sSUFBSUcsTUFDUjtJQUVKO0FBQ0Y7QUFFQSxTQUFTQyxrQkFBa0JKLEtBQUE7SUFDekIsTUFBTUssZUFBZU4sMEJBQTBCQztJQUUvQyxJQUFJLENBQUNLLGdCQUFnQixPQUFPTCxVQUFVLGFBQWE7UUFDakQsTUFBTSxJQUFJRyxNQUNSO0lBRUo7SUFFQSxPQUFPRTtBQUNUO0FBZ0NPLFNBQVNDLG9CQUNkQyxlQUFBO0lBRUFMLHNCQUFzQks7SUFFdEIsT0FBTztRQUNMLENBQUNiLE9BQU9jLGFBQWE7WUFDbkIsSUFBSUMsTUFDRkY7WUFDRixJQUFJRyxPQUFPRCxJQUFJQyxJQUFBO1lBQ2YsSUFBSUMsT0FBTztZQUNYLElBQUlDLFVBQVU7WUFFZCxPQUFPO2dCQUNMLE1BQU1DO29CQUNKLElBQUlGLE1BQU0sT0FBTzt3QkFBRVgsT0FBT1U7d0JBQU1DLE1BQU07b0JBQUs7b0JBRTNDRixNQUFNLE1BQU1BO29CQUVaLElBQUksT0FBT0EsSUFBSUssS0FBQSxLQUFVLGFBQWE7d0JBQ3BDLE1BQU1MLElBQUlLLEtBQUE7b0JBQ1o7b0JBQ0EsSUFBSSxVQUFVTCxPQUFPQSxJQUFJTSxJQUFBLEVBQU07d0JBQzdCLElBQUlOLElBQUlNLElBQUEsRUFBTTs0QkFDWixPQUFRTixJQUFJ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QyxVQUFnQnhELDZDQUFBLENBQWNRO0lBQ3BDLE9BQU9nRDtBQUNUO0FBRU8sU0FBU0M7SUFDZCxNQUFNQyxjQUFvQjFELDZDQUFBLENBQ3hCUztJQUdGLElBQUlpRCxnQkFBZ0IsTUFBTTtRQUN4QixNQUFNLElBQUloRixNQUFNO0lBQ2xCO0lBRUEsT0FBT2dGO0FBQ1Q7O0FFOU5vQztBQUk3QixTQUFTQywyQkFBOEIsRUFDNUNMLENBQUEsRUFDRjtJQUlFLE1BQU0sQ0FBQy9FLE9BQU9xRixTQUFRLEdBQUk3RiwrQ0FBQUEsQ0FBd0J1RixFQUFFckUsSUFBSTtJQUl4RCxNQUFNLENBQUNJLE9BQU9LLFNBQVEsR0FBSTNCLCtDQUFBQSxDQUE0QnVGLEVBQUVqRSxLQUFLO0lBRTdEc0MsZ0RBQUFBLENBQVU7UUFDUixJQUFJa0MsV0FBVztRQUNmbkUsU0FBUztRQUVSO1lBQ0MsSUFBSTtnQkFFRixpQkFBaUJvRSxLQUFLakYsb0JBQW9CeUUsR0FBSTtvQkFDNUMsSUFBSU8sVUFBVTt3QkFDWjtvQkFDRjtvQkFFQUQsU0FBU0U7Z0JBQ1g7WUFDRixTQUFTL0QsR0FBRztnQkFDVixJQUFJOEQsVUFBVTtvQkFDWjtnQkFDRjtnQkFFQW5FLFNBQVNLO1lBQ1g7UUFDRjtRQUVBLE9BQU87WUFFTDhELFdBQVc7UUFDYjtJQUNGLEdBQUc7UUFBQ1A7S0FBRTtJQUtOLElBQUlqRSxPQUFPO1FBQ1QsTUFBTUE7SUFDUjtJQUVBLE9BQU9kO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vc2hhcmVkLWNsaWVudC9zdHJlYW1hYmxlLnRzeD9lMThiIiwid2VicGFjazovL3dlYi8uLi9jb25zdGFudHMudHM/YWI3MiIsIndlYnBhY2s6Ly93ZWIvLi4vc2hhcmVkLWNsaWVudC9jb250ZXh0LnRzeD9jYjNmIiwid2VicGFjazovL3dlYi8uLi91dGlscy50c3g/N2EyZSIsIndlYnBhY2s6Ly93ZWIvLi4vc2hhcmVkLWNsaWVudC9jbGllbnQtd3JhcHBlci50c3g/OTk3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBSZWFjdEVsZW1lbnQsXG4gIHN0YXJ0VHJhbnNpdGlvbixcbiAgdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VTdGF0ZSxcbn0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgU1RSRUFNQUJMRV9WQUxVRV9UWVBFIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB0eXBlIHsgU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5mdW5jdGlvbiBoYXNSZWFkYWJsZVZhbHVlU2lnbmF0dXJlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU3RyZWFtYWJsZVZhbHVlIHtcbiAgcmV0dXJuICEhKFxuICAgIHZhbHVlICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICd0eXBlJyBpbiB2YWx1ZSAmJlxuICAgIHZhbHVlLnR5cGUgPT09IFNUUkVBTUFCTEVfVkFMVUVfVFlQRVxuICApO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTdHJlYW1hYmxlVmFsdWUoXG4gIHZhbHVlOiB1bmtub3duLFxuKTogYXNzZXJ0cyB2YWx1ZSBpcyBTdHJlYW1hYmxlVmFsdWUge1xuICBpZiAoIWhhc1JlYWRhYmxlVmFsdWVTaWduYXR1cmUodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ludmFsaWQgdmFsdWU6IHRoaXMgaG9vayBvbmx5IGFjY2VwdHMgdmFsdWVzIGNyZWF0ZWQgdmlhIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWVgLicsXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0cmVhbWFibGVWYWx1ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFN0cmVhbWFibGVWYWx1ZSB7XG4gIGNvbnN0IGhhc1NpZ25hdHVyZSA9IGhhc1JlYWRhYmxlVmFsdWVTaWduYXR1cmUodmFsdWUpO1xuXG4gIGlmICghaGFzU2lnbmF0dXJlICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW52YWxpZCB2YWx1ZTogdGhpcyBob29rIG9ubHkgYWNjZXB0cyB2YWx1ZXMgY3JlYXRlZCB2aWEgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZWAuJyxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGhhc1NpZ25hdHVyZTtcbn1cblxuLyoqXG4gKiBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdGFrZXMgYSBzdHJlYW1hYmxlIHZhbHVlIGNyZWF0ZWQgdmlhIHRoZSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCkudmFsdWVgIEFQSSxcbiAqIGFuZCByZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBJbnNpZGUgeW91ciBBSSBhY3Rpb246XG4gKlxuICogYXN5bmMgZnVuY3Rpb24gYWN0aW9uKCkge1xuICogICAndXNlIHNlcnZlcidcbiAqICAgY29uc3Qgc3RyZWFtYWJsZSA9IGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgpO1xuICpcbiAqICAgc3RyZWFtYWJsZS51cGRhdGUoMSk7XG4gKiAgIHN0cmVhbWFibGUudXBkYXRlKDIpO1xuICogICBzdHJlYW1hYmxlLmRvbmUoMyk7XG4gKiAgIC8vIC4uLlxuICogICByZXR1cm4gc3RyZWFtYWJsZS52YWx1ZTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFuZCB0byByZWFkIHRoZSB2YWx1ZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3Qgc3RyZWFtYWJsZVZhbHVlID0gYXdhaXQgYWN0aW9uKClcbiAqIGZvciBhd2FpdCAoY29uc3QgdiBvZiByZWFkU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkpIHtcbiAqICAgY29uc29sZS5sb2codilcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoaXMgbG9ncyBvdXQgMSwgMiwgMyBvbiBjb25zb2xlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZFN0cmVhbWFibGVWYWx1ZTxUID0gdW5rbm93bj4oXG4gIHN0cmVhbWFibGVWYWx1ZTogU3RyZWFtYWJsZVZhbHVlPFQ+LFxuKTogQXN5bmNJdGVyYWJsZTxUIHwgdW5kZWZpbmVkPiB7XG4gIGFzc2VydFN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIGxldCByb3c6IFN0cmVhbWFibGVWYWx1ZTxUPiB8IFByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQ+PiA9XG4gICAgICAgIHN0cmVhbWFibGVWYWx1ZTtcbiAgICAgIGxldCBjdXJyID0gcm93LmN1cnI7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgbGV0IGluaXRpYWwgPSB0cnVlO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm4geyB2YWx1ZTogY3VyciwgZG9uZTogdHJ1ZSB9O1xuXG4gICAgICAgICAgcm93ID0gYXdhaXQgcm93O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiByb3cuZXJyb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyByb3cuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnY3VycicgaW4gcm93IHx8IHJvdy5kaWZmKSB7XG4gICAgICAgICAgICBpZiAocm93LmRpZmYpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChyb3cuZGlmZlswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VyciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIHBhdGNoOiBjYW4gb25seSBhcHBlbmQgdG8gc3RyaW5nIHR5cGVzLiBUaGlzIGlzIGEgYnVnIGluIHRoZSBBSSBTREsuJyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIChjdXJyIGFzIHN0cmluZykgPSBjdXJyICsgcm93LmRpZmZbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAoY3VyciBhcyBSZWFjdEVsZW1lbnQpID0gKFxuICAgICAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICAgIHtjdXJyfVxuICAgICAgICAgICAgICAgICAgICAgIHtyb3cuZGlmZlsxXX1cbiAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnIgPSByb3cuY3VycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGxhc3QgZW1pdHRlZCB7IGRvbmU6IHRydWUgfSB3b24ndCBiZSB1c2VkIGFzIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gYnkgdGhlIGZvciBhd2FpdC4uLm9mIHN5bnRheC5cbiAgICAgICAgICAgIGlmICghcm93Lm5leHQpIHtcbiAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1cnIsXG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFyb3cubmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGN1cnIsXG4gICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdyA9IHJvdy5uZXh0O1xuICAgICAgICAgIGlmIChpbml0aWFsKSB7XG4gICAgICAgICAgICBpbml0aWFsID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGluaXRpYWwgY2h1bmsgYW5kIHRoZXJlIGlzbid0IGFuIGluaXRpYWwgdmFsdWUgeWV0LlxuICAgICAgICAgICAgICAvLyBMZXQncyBza2lwIHRoaXMgb25lLlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBjdXJyLFxuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcbiAgfTtcbn1cblxuLyoqXG4gKiBgdXNlU3RyZWFtYWJsZVZhbHVlYCBpcyBhIFJlYWN0IGhvb2sgdGhhdCB0YWtlcyBhIHN0cmVhbWFibGUgdmFsdWUgY3JlYXRlZCB2aWEgdGhlIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoKS52YWx1ZWAgQVBJLFxuICogYW5kIHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUsIGVycm9yLCBhbmQgcGVuZGluZyBzdGF0ZS5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY29uc3VtaW5nIHN0cmVhbWFibGUgdmFsdWVzIHJlY2VpdmVkIGZyb20gYSBjb21wb25lbnQncyBwcm9wcy4gRm9yIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGZ1bmN0aW9uIE15Q29tcG9uZW50KHsgc3RyZWFtYWJsZVZhbHVlIH0pIHtcbiAqICAgY29uc3QgW2RhdGEsIGVycm9yLCBwZW5kaW5nXSA9IHVzZVN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpO1xuICpcbiAqICAgaWYgKHBlbmRpbmcpIHJldHVybiA8ZGl2PkxvYWRpbmcuLi48L2Rpdj47XG4gKiAgIGlmIChlcnJvcikgcmV0dXJuIDxkaXY+RXJyb3I6IHtlcnJvci5tZXNzYWdlfTwvZGl2PjtcbiAqXG4gKiAgIHJldHVybiA8ZGl2PkRhdGE6IHtkYXRhfTwvZGl2PjtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RyZWFtYWJsZVZhbHVlPFQgPSB1bmtub3duLCBFcnJvciA9IHVua25vd24+KFxuICBzdHJlYW1hYmxlVmFsdWU/OiBTdHJlYW1hYmxlVmFsdWU8VD4sXG4pOiBbZGF0YTogVCB8IHVuZGVmaW5lZCwgZXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkLCBwZW5kaW5nOiBib29sZWFuXSB7XG4gIGNvbnN0IFtjdXJyLCBzZXRDdXJyXSA9IHVzZVN0YXRlPFQgfCB1bmRlZmluZWQ+KFxuICAgIGlzU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkgPyBzdHJlYW1hYmxlVmFsdWUuY3VyciA6IHVuZGVmaW5lZCxcbiAgKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxFcnJvciB8IHVuZGVmaW5lZD4oXG4gICAgaXNTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSA/IHN0cmVhbWFibGVWYWx1ZS5lcnJvciA6IHVuZGVmaW5lZCxcbiAgKTtcbiAgY29uc3QgW3BlbmRpbmcsIHNldFBlbmRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oXG4gICAgaXNTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSA/ICEhc3RyZWFtYWJsZVZhbHVlLm5leHQgOiBmYWxzZSxcbiAgKTtcblxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSkgcmV0dXJuO1xuXG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSByZWFkU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSk7XG4gICAgaWYgKHN0cmVhbWFibGVWYWx1ZS5uZXh0KSB7XG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIHNldFBlbmRpbmcodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBpdGVyYXRvcikge1xuICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0Q3Vycih2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICBzZXRFcnJvcihlIGFzIEVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIHNldFBlbmRpbmcoZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgfSwgW3N0cmVhbWFibGVWYWx1ZV0pO1xuXG4gIHJldHVybiBbY3VyciwgZXJyb3IsIHBlbmRpbmddO1xufVxuIiwiZXhwb3J0IGNvbnN0IFNUUkVBTUFCTEVfVkFMVUVfVFlQRSA9IFN5bWJvbC5mb3IoJ3VpLnN0cmVhbWFibGUudmFsdWUnKTtcbmV4cG9ydCBjb25zdCBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSA9IDE1ICogMTAwMDtcbiIsIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAqL1xuJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCAqIGFzIGpzb25kaWZmcGF0Y2ggZnJvbSAnanNvbmRpZmZwYXRjaCc7XG5pbXBvcnQgdHlwZSB7XG4gIEludGVybmFsQUlQcm92aWRlclByb3BzLFxuICBBSVByb3ZpZGVyLFxuICBJbmZlckFJU3RhdGUsXG4gIFZhbHVlT3JVcGRhdGVyLFxuICBJbmZlckFjdGlvbnMsXG4gIEluZmVyVUlTdGF0ZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PG51bGwgfCBhbnk+KG51bGwpO1xuY29uc3QgSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PHVuZGVmaW5lZCB8IGFueT4odW5kZWZpbmVkKTtcbmNvbnN0IEludGVybmFsQWN0aW9uUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PG51bGwgfCBhbnk+KG51bGwpO1xuY29uc3QgSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDxudWxsIHwgYW55PihudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIEludGVybmFsQUlQcm92aWRlcih7XG4gIGNoaWxkcmVuLFxuICBpbml0aWFsVUlTdGF0ZSxcbiAgaW5pdGlhbEFJU3RhdGUsXG4gIGluaXRpYWxBSVN0YXRlUGF0Y2gsXG4gIHdyYXBwZWRBY3Rpb25zLFxuICB3cmFwcGVkU3luY1VJU3RhdGUsXG59OiBJbnRlcm5hbEFJUHJvdmlkZXJQcm9wcykge1xuICBpZiAoISgndXNlJyBpbiBSZWFjdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFJlYWN0IHZlcnNpb24uJyk7XG4gIH1cblxuICBjb25zdCB1aVN0YXRlID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbFVJU3RhdGUpO1xuICBjb25zdCBzZXRVSVN0YXRlID0gdWlTdGF0ZVsxXTtcblxuICBjb25zdCByZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2ggPSBpbml0aWFsQUlTdGF0ZVBhdGNoXG4gICAgPyAoUmVhY3QgYXMgYW55KS51c2UoaW5pdGlhbEFJU3RhdGVQYXRjaClcbiAgICA6IHVuZGVmaW5lZDtcbiAgaW5pdGlhbEFJU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoKSB7XG4gICAgICByZXR1cm4ganNvbmRpZmZwYXRjaC5wYXRjaChcbiAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShpbml0aWFsQUlTdGF0ZSksXG4gICAgICAgIHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBpbml0aWFsQUlTdGF0ZTtcbiAgfSwgW2luaXRpYWxBSVN0YXRlLCByZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2hdKTtcblxuICBjb25zdCBhaVN0YXRlID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbEFJU3RhdGUpO1xuICBjb25zdCBzZXRBSVN0YXRlID0gYWlTdGF0ZVsxXTtcbiAgY29uc3QgYWlTdGF0ZVJlZiA9IFJlYWN0LnVzZVJlZihhaVN0YXRlWzBdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFpU3RhdGVSZWYuY3VycmVudCA9IGFpU3RhdGVbMF07XG4gIH0sIFthaVN0YXRlWzBdXSk7XG5cbiAgY29uc3QgY2xpZW50V3JhcHBlZEFjdGlvbnMgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+XG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHdyYXBwZWRBY3Rpb25zKS5tYXAoKFtrZXksIGFjdGlvbl0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgYXN5bmMgKC4uLmFyZ3M6IGFueSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWlTdGF0ZVNuYXBzaG90ID0gYWlTdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgY29uc3QgW2FpU3RhdGVEZWx0YSwgcmVzdWx0XSA9IGF3YWl0IGFjdGlvbihcbiAgICAgICAgICAgICAgYWlTdGF0ZVNuYXBzaG90LFxuICAgICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYXdhaXQgYWlTdGF0ZURlbHRhO1xuICAgICAgICAgICAgICBpZiAoZGVsdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFpU3RhdGVbMV0oXG4gICAgICAgICAgICAgICAgICBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICAgICAgICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGFpU3RhdGVTbmFwc2hvdCksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9LFxuICAgICAgICBdKSxcbiAgICAgICksXG4gICAgW3dyYXBwZWRBY3Rpb25zXSxcbiAgKTtcblxuICBjb25zdCBjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb24gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIXdyYXBwZWRTeW5jVUlTdGF0ZSkge1xuICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhaVN0YXRlU25hcHNob3QgPSBhaVN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBbYWlTdGF0ZURlbHRhLCB1aVN0YXRlXSA9IGF3YWl0IHdyYXBwZWRTeW5jVUlTdGF0ZSEoXG4gICAgICAgIGFpU3RhdGVTbmFwc2hvdCxcbiAgICAgICk7XG5cbiAgICAgIGlmICh1aVN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0VUlTdGF0ZSh1aVN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVsdGEgPSBhd2FpdCBhaVN0YXRlRGVsdGE7XG4gICAgICBpZiAoZGVsdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwYXRjaGVkQWlTdGF0ZSA9IGpzb25kaWZmcGF0Y2gucGF0Y2goXG4gICAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShhaVN0YXRlU25hcHNob3QpLFxuICAgICAgICAgIGRlbHRhLFxuICAgICAgICApO1xuICAgICAgICBzZXRBSVN0YXRlKHBhdGNoZWRBaVN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbd3JhcHBlZFN5bmNVSVN0YXRlXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8SW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXIgdmFsdWU9e2FpU3RhdGV9PlxuICAgICAgPEludGVybmFsVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyIHZhbHVlPXt1aVN0YXRlfT5cbiAgICAgICAgPEludGVybmFsQWN0aW9uUHJvdmlkZXIuUHJvdmlkZXIgdmFsdWU9e2NsaWVudFdyYXBwZWRBY3Rpb25zfT5cbiAgICAgICAgICA8SW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyXG4gICAgICAgICAgICB2YWx1ZT17Y2xpZW50V3JhcHBlZFN5bmNVSVN0YXRlQWN0aW9ufVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICA8L0ludGVybmFsU3luY1VJU3RhdGVQcm92aWRlci5Qcm92aWRlcj5cbiAgICAgICAgPC9JbnRlcm5hbEFjdGlvblByb3ZpZGVyLlByb3ZpZGVyPlxuICAgICAgPC9JbnRlcm5hbFVJU3RhdGVQcm92aWRlci5Qcm92aWRlcj5cbiAgICA8L0ludGVybmFsQUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCkge1xuICB0eXBlIFQgPSBJbmZlclVJU3RhdGU8QUksIGFueT47XG5cbiAgY29uc3Qgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0PFxuICAgIFtULCAodjogVCB8ICgodl86IFQpID0+IFQpKSA9PiB2b2lkXSB8IG51bGwgfCB1bmRlZmluZWRcbiAgPihJbnRlcm5hbFVJU3RhdGVQcm92aWRlcik7XG4gIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYHVzZVVJU3RhdGVgIG11c3QgYmUgdXNlZCBpbnNpZGUgYW4gPEFJPiBwcm92aWRlci4nKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gIH1cbiAgaWYgKHN0YXRlWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYGluaXRpYWxVSVN0YXRlYCBtdXN0IGJlIHByb3ZpZGVkIHRvIGBjcmVhdGVBSWAgb3IgYDxBST5gJyxcbiAgICApO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLy8gVE9ETzogSG93IGRvIHdlIGF2b2lkIGNhdXNpbmcgYSByZS1yZW5kZXIgd2hlbiB0aGUgQUkgc3RhdGUgY2hhbmdlcyBidXQgeW91XG4vLyBhcmUgb25seSBsaXN0ZW5pbmcgdG8gYSBzcGVjaWZpYyBrZXk/IFdlIG5lZWQgdXNlU0VTIHBlcmhhcHM/XG5mdW5jdGlvbiB1c2VBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKTogW1xuICBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4gIChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8SW5mZXJBSVN0YXRlPEFJLCBhbnk+PikgPT4gdm9pZCxcbl07XG5mdW5jdGlvbiB1c2VBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIGtleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+LFxuKTogW1xuICBJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV0sXG4gIChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8SW5mZXJBSVN0YXRlPEFJLCBhbnk+W3R5cGVvZiBrZXldPikgPT4gdm9pZCxcbl07XG5mdW5jdGlvbiB1c2VBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIC4uLmFyZ3M6IFtdIHwgW2tleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pl1cbikge1xuICB0eXBlIFQgPSBJbmZlckFJU3RhdGU8QUksIGFueT47XG5cbiAgY29uc3Qgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0PFxuICAgIFtULCAobmV3U3RhdGU6IFZhbHVlT3JVcGRhdGVyPFQ+KSA9PiB2b2lkXSB8IG51bGwgfCB1bmRlZmluZWRcbiAgPihJbnRlcm5hbEFJU3RhdGVQcm92aWRlcik7XG4gIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYHVzZUFJU3RhdGVgIG11c3QgYmUgdXNlZCBpbnNpZGUgYW4gPEFJPiBwcm92aWRlci4nKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gIH1cbiAgaWYgKHN0YXRlWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYGluaXRpYWxBSVN0YXRlYCBtdXN0IGJlIHByb3ZpZGVkIHRvIGBjcmVhdGVBSWAgb3IgYDxBST5gJyxcbiAgICApO1xuICB9XG4gIGlmIChhcmdzLmxlbmd0aCA+PSAxICYmIHR5cGVvZiBzdGF0ZVswXSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnV2hlbiB1c2luZyBgdXNlQUlTdGF0ZWAgd2l0aCBhIGtleSwgdGhlIEFJIHN0YXRlIG11c3QgYmUgYW4gb2JqZWN0LicsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gIGNvbnN0IHNldHRlciA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnXG4gICAgICA/IHN0YXRlWzFdXG4gICAgICA6IChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8VD4pID0+IHtcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZVsxXShzID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucywgW2tleV06IG5ld1N0YXRlKHNba2V5XSkgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVbMV0oeyAuLi5zdGF0ZVswXSwgW2tleV06IG5ld1N0YXRlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBba2V5XSxcbiAgKTtcblxuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtzdGF0ZVswXVthcmdzWzBdXSwgc2V0dGVyXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aW9uczxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCkge1xuICB0eXBlIFQgPSBJbmZlckFjdGlvbnM8QUksIGFueT47XG5cbiAgY29uc3QgYWN0aW9ucyA9IFJlYWN0LnVzZUNvbnRleHQ8VD4oSW50ZXJuYWxBY3Rpb25Qcm92aWRlcik7XG4gIHJldHVybiBhY3Rpb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3luY1VJU3RhdGUoKSB7XG4gIGNvbnN0IHN5bmNVSVN0YXRlID0gUmVhY3QudXNlQ29udGV4dDwoKSA9PiBQcm9taXNlPHZvaWQ+PihcbiAgICBJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIsXG4gICk7XG5cbiAgaWYgKHN5bmNVSVN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdXNlU3luY1VJU3RhdGVgIG11c3QgYmUgdXNlZCBpbnNpZGUgYW4gPEFJPiBwcm92aWRlci4nKTtcbiAgfVxuXG4gIHJldHVybiBzeW5jVUlTdGF0ZTtcbn1cblxuZXhwb3J0IHsgdXNlQUlTdGF0ZSB9O1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPFQgPSBhbnk+KCkge1xuICBsZXQgcmVzb2x2ZTogKHZhbHVlOiBUKSA9PiB2b2lkLCByZWplY3Q6IChlcnJvcjogdW5rbm93bikgPT4gdm9pZDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmU6IHJlc29sdmUhLFxuICAgIHJlamVjdDogcmVqZWN0ISxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAoeDogdW5rbm93bik6IHggaXMgRnVuY3Rpb24gPT5cbiAgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBjb25zdCBjb25zdW1lU3RyZWFtID0gYXN5bmMgKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pID0+IHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkgYnJlYWs7XG4gIH1cbn07XG4iLCIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyByZWFkU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi9zdHJlYW1hYmxlJztcblxuZXhwb3J0IGZ1bmN0aW9uIEludGVybmFsU3RyZWFtYWJsZVVJQ2xpZW50PFQ+KHtcbiAgcyxcbn06IHtcbiAgczogU3RyZWFtYWJsZVZhbHVlPFQ+O1xufSkge1xuICAvLyBTZXQgdGhlIHZhbHVlIHRvIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlLCBpZiBpdCBoYXMgb25lLlxuICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHVzZVN0YXRlPFQgfCB1bmRlZmluZWQ+KHMuY3Vycik7XG5cbiAgLy8gRXJyb3Igc3RhdGUgZm9yIHRoZSBzdHJlYW1hYmxlLiBJdCBtaWdodCBiZSBlcnJvcmVkIGluaXRpYWxseSBhbmQgd2Ugd2FudFxuICAvLyB0byBlcnJvciBvdXQgYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxFcnJvciB8IHVuZGVmaW5lZD4ocy5lcnJvcik7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBzZXRFcnJvcih1bmRlZmluZWQpO1xuXG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFJlYWQgdGhlIHN0cmVhbWFibGUgdmFsdWUgYW5kIHVwZGF0ZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IHZhbHVlLlxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHYgb2YgcmVhZFN0cmVhbWFibGVWYWx1ZShzKSkge1xuICAgICAgICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0VmFsdWUodik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0RXJyb3IoZSBhcyBFcnJvcik7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBJZiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZCwgd2Ugd2FudCB0byBjYW5jZWwgdGhlIHN0cmVhbS5cbiAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbc10pO1xuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGVycm9ycyBmcm9tIHRoZSBzdHJlYW1hYmxlIFVJIGFyZSB0aHJvd24gZHVyaW5nIHRoZVxuICAvLyByZW5kZXIgcGhhc2UsIHNvIHRoYXQgdGhleSBjYW4gYmUgY2F1Z2h0IGJ5IGVycm9yIGJvdW5kYXJ5IGNvbXBvbmVudHMuXG4gIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBSZWFjdCdzIGRlY2xhcmF0aXZlIG1vZGVsLlxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbiJdLCJuYW1lcyI6WyJzdGFydFRyYW5zaXRpb24iLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VTdGF0ZSIsIlNUUkVBTUFCTEVfVkFMVUVfVFlQRSIsIlN5bWJvbCIsImZvciIsIkRFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FIiwiRnJhZ21lbnQiLCJqc3hzIiwiaGFzUmVhZGFibGVWYWx1ZVNpZ25hdHVyZSIsInZhbHVlIiwidHlwZSIsImFzc2VydFN0cmVhbWFibGVWYWx1ZSIsIkVycm9yIiwiaXNTdHJlYW1hYmxlVmFsdWUiLCJoYXNTaWduYXR1cmUiLCJyZWFkU3RyZWFtYWJsZVZhbHVlIiwic3RyZWFtYWJsZVZhbHVlIiwiYXN5bmNJdGVyYXRvciIsInJvdyIsImN1cnIiLCJkb25lIiwiaW5pdGlhbCIsIm5leHQiLCJlcnJvciIsImRpZmYiLCJjaGlsZHJlbiIsInVzZVN0cmVhbWFibGVWYWx1ZSIsInNldEN1cnIiLCJzZXRFcnJvciIsInBlbmRpbmciLCJzZXRQZW5kaW5nIiwiY2FuY2VsbGVkIiwiaXRlcmF0b3IiLCJlIiwiUmVhY3QiLCJqc29uZGlmZnBhdGNoIiwiaXNGdW5jdGlvbiIsIngiLCJqc3giLCJJbnRlcm5hbFVJU3RhdGVQcm92aWRlciIsImNyZWF0ZUNvbnRleHQiLCJJbnRlcm5hbEFJU3RhdGVQcm92aWRlciIsIkludGVybmFsQWN0aW9uUHJvdmlkZXIiLCJJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIiLCJJbnRlcm5hbEFJUHJvdmlkZXIiLCJpbml0aWFsVUlTdGF0ZSIsImluaXRpYWxBSVN0YXRlIiwiaW5pdGlhbEFJU3RhdGVQYXRjaCIsIndyYXBwZWRBY3Rpb25zIiwid3JhcHBlZFN5bmNVSVN0YXRlIiwidWlTdGF0ZSIsInNldFVJU3RhdGUiLCJyZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2giLCJ1c2UiLCJ1c2VNZW1vIiwicGF0Y2giLCJjbG9uZSIsImFpU3RhdGUiLCJzZXRBSVN0YXRlIiwiYWlTdGF0ZVJlZiIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJjbGllbnRXcmFwcGVkQWN0aW9ucyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIm1hcCIsImtleSIsImFjdGlvbiIsImFyZ3MiLCJhaVN0YXRlU25hcHNob3QiLCJhaVN0YXRlRGVsdGEiLCJyZXN1bHQiLCJkZWx0YSIsImNsaWVudFdyYXBwZWRTeW5jVUlTdGF0ZUFjdGlvbiIsInBhdGNoZWRBaVN0YXRlIiwiUHJvdmlkZXIiLCJ1c2VVSVN0YXRlIiwic3RhdGUiLCJ1c2VDb250ZXh0IiwiQXJyYXkiLCJpc0FycmF5IiwidXNlQUlTdGF0ZSIsImxlbmd0aCIsInNldHRlciIsInVzZUNhbGxiYWNrIiwibmV3U3RhdGUiLCJzIiwidXNlQWN0aW9ucyIsImFjdGlvbnMiLCJ1c2VTeW5jVUlTdGF0ZSIsInN5bmNVSVN0YXRlIiwiSW50ZXJuYWxTdHJlYW1hYmxlVUlDbGllbnQiLCJzZXRWYWx1ZSIsImNhbmNlbGVkIiwidiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/rsc/dist/rsc-server.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-server.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_4___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$ACTION_0: () => (/* binding */ $$ACTION_0),\n/* harmony export */   createAI: () => (/* binding */ createAI),\n/* harmony export */   createStreamableUI: () => (/* binding */ createStreamableUI),\n/* harmony export */   createStreamableValue: () => (/* binding */ createStreamableValue),\n/* harmony export */   getAIState: () => (/* binding */ getAIState),\n/* harmony export */   getMutableAIState: () => (/* binding */ getMutableAIState),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   streamUI: () => (/* binding */ streamUI)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(rsc)/./node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jsondiffpatch */ \"(rsc)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./rsc-shared.mjs */ \"(rsc)/./node_modules/ai/rsc/dist/rsc-shared.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n// rsc/ai-state.tsx\n/* __next_internal_action_entry_do_not_use__ {\"b521eb735db1932b4b53160e146fff6850ebefc7\":\"$$ACTION_0\"} */ \n\n\n\n// rsc/utils.tsx\nfunction createResolvablePromise() {\n    let resolve, reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\nvar isFunction = (x)=>typeof x === \"function\";\nvar consumeStream = async (stream)=>{\n    const reader = stream.getReader();\n    while(true){\n        const { done } = await reader.read();\n        if (done) break;\n    }\n};\n// rsc/ai-state.tsx\nvar asyncAIStateStorage = new async_hooks__WEBPACK_IMPORTED_MODULE_2__.AsyncLocalStorage();\nfunction getAIStateStoreOrThrow(message) {\n    const store = asyncAIStateStorage.getStore();\n    if (!store) {\n        throw new Error(message);\n    }\n    return store;\n}\nfunction withAIState({ state: state1, options }, fn) {\n    return asyncAIStateStorage.run({\n        currentState: state1,\n        originalState: state1,\n        sealed: false,\n        options\n    }, fn);\n}\nfunction getAIStateDeltaPromise() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    return store.mutationDeltaPromise;\n}\nfunction sealMutableAIState() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    store.sealed = true;\n}\nfunction getAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getAIState` must be called within an AI Action.\");\n    if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== \"object\") {\n            throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n        }\n        return store.currentState[key];\n    }\n    return store.currentState;\n}\nfunction getMutableAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getMutableAIState` must be called within an AI Action.\");\n    if (store.sealed) {\n        throw new Error(\"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\");\n    }\n    if (!store.mutationDeltaPromise) {\n        const { promise, resolve } = createResolvablePromise();\n        store.mutationDeltaPromise = promise;\n        store.mutationDeltaResolve = resolve;\n    }\n    function doUpdate(newState, done) {\n        var _a, _b;\n        if (args.length > 0) {\n            if (typeof store.currentState !== \"object\") {\n                const key = args[0];\n                throw new Error(`You can't modify the \"${String(key)}\" field of the AI state because it's not an object.`);\n            }\n        }\n        if (isFunction(newState)) {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState(store.currentState[args[0]]);\n            } else {\n                store.currentState = newState(store.currentState);\n            }\n        } else {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState;\n            } else {\n                store.currentState = newState;\n            }\n        }\n        (_b = (_a = store.options).onSetAIState) == null ? void 0 : _b.call(_a, {\n            key: args.length > 0 ? args[0] : void 0,\n            state: store.currentState,\n            done\n        });\n    }\n    const mutableState = {\n        get: ()=>{\n            if (args.length > 0) {\n                const key = args[0];\n                if (typeof store.currentState !== \"object\") {\n                    throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n                }\n                return store.currentState[key];\n            }\n            return store.currentState;\n        },\n        update: function update(newAIState) {\n            doUpdate(newAIState, false);\n        },\n        done: function done(...doneArgs) {\n            if (doneArgs.length > 0) {\n                doUpdate(doneArgs[0], true);\n            }\n            const delta = jsondiffpatch__WEBPACK_IMPORTED_MODULE_3__.diff(store.originalState, store.currentState);\n            store.mutationDeltaResolve(delta);\n        }\n    };\n    return mutableState;\n}\n// rsc/streamable.tsx\n\n\n// core/util/retry-with-exponential-backoff.ts\n\n\n// core/util/delay.ts\nasync function delay(delayInMs) {\n    return new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// core/util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_6__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_6__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_6__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded image.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidDataContentError({\n        content\n    });\n}\n// core/prompt/invalid-message-role-error.ts\nvar InvalidMessageRoleError = class extends Error {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super(message);\n        this.name = \"AI_InvalidMessageRoleError\";\n        this.role = role;\n    }\n    static isInvalidMessageRoleError(error) {\n        return error instanceof Error && error.name === \"AI_InvalidMessageRoleError\" && typeof error.role === \"string\";\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            role: this.role\n        };\n    }\n};\n// core/prompt/convert-to-language-model-prompt.ts\n\nfunction convertToLanguageModelPrompt(prompt) {\n    const languageModelMessages = [];\n    if (prompt.system != null) {\n        languageModelMessages.push({\n            role: \"system\",\n            content: prompt.system\n        });\n    }\n    const promptType = prompt.type;\n    switch(promptType){\n        case \"prompt\":\n            {\n                languageModelMessages.push({\n                    role: \"user\",\n                    content: [\n                        {\n                            type: \"text\",\n                            text: prompt.prompt\n                        }\n                    ]\n                });\n                break;\n            }\n        case \"messages\":\n            {\n                languageModelMessages.push(...prompt.messages.map(convertToLanguageModelMessage));\n                break;\n            }\n        default:\n            {\n                const _exhaustiveCheck = promptType;\n                throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n            }\n    }\n    return languageModelMessages;\n}\nfunction convertToLanguageModelMessage(message) {\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ]\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>{\n                        var _a;\n                        switch(part.type){\n                            case \"text\":\n                                {\n                                    return part;\n                                }\n                            case \"image\":\n                                {\n                                    if (part.image instanceof URL) {\n                                        return {\n                                            type: \"image\",\n                                            image: part.image,\n                                            mimeType: part.mimeType\n                                        };\n                                    }\n                                    if (typeof part.image === \"string\") {\n                                        try {\n                                            const url = new URL(part.image);\n                                            switch(url.protocol){\n                                                case \"http:\":\n                                                case \"https:\":\n                                                    {\n                                                        return {\n                                                            type: \"image\",\n                                                            image: url,\n                                                            mimeType: part.mimeType\n                                                        };\n                                                    }\n                                                case \"data:\":\n                                                    {\n                                                        try {\n                                                            const [header, base64Content] = part.image.split(\",\");\n                                                            const mimeType = header.split(\";\")[0].split(\":\")[1];\n                                                            if (mimeType == null || base64Content == null) {\n                                                                throw new Error(\"Invalid data URL format\");\n                                                            }\n                                                            return {\n                                                                type: \"image\",\n                                                                image: convertDataContentToUint8Array(base64Content),\n                                                                mimeType\n                                                            };\n                                                        } catch (error) {\n                                                            throw new Error(`Error processing data URL: ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_6__.getErrorMessage)(message)}`);\n                                                        }\n                                                    }\n                                                default:\n                                                    {\n                                                        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n                                                    }\n                                            }\n                                        } catch (_ignored) {}\n                                    }\n                                    const imageUint8 = convertDataContentToUint8Array(part.image);\n                                    return {\n                                        type: \"image\",\n                                        image: imageUint8,\n                                        mimeType: (_a = part.mimeType) != null ? _a : detectImageMimeType(imageUint8)\n                                    };\n                                }\n                        }\n                    })\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ]\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts:\n                    (part)=>part.type !== \"text\" || part.text !== \"\")\n                };\n            }\n        case \"tool\":\n            {\n                return message;\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    return prompt.prompt != null ? {\n        type: \"prompt\",\n        prompt: prompt.prompt,\n        messages: void 0,\n        system: prompt.system\n    } : {\n        type: \"messages\",\n        prompt: void 0,\n        messages: prompt.messages,\n        // only possible case bc of checks above\n        system: prompt.system\n    };\n}\n// core/prompt/prepare-call-settings.ts\n\nfunction prepareCallSettings({ maxTokens, temperature, topP, presencePenalty, frequencyPenalty, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        presencePenalty,\n        frequencyPenalty,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/util/convert-zod-to-json-schema.ts\n\nfunction convertZodToJSONSchema(zodSchema) {\n    return (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(zodSchema);\n}\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n    return object != null && Object.keys(object).length > 0;\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({ tools, toolChoice }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    return {\n        tools: Object.entries(tools).map(([name, tool])=>({\n                type: \"function\",\n                name,\n                description: tool.description,\n                parameters: convertZodToJSONSchema(tool.parameters)\n            })),\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_8__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a;\n            await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\n\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__.formatStreamPart)(\"text\", message)));\n        }\n    });\n}\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a = choice.delta) == null ? void 0 : _a.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__.createChunkDecoder)();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__.formatStreamPart)(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: JSON.parse(tool.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__.formatStreamPart)(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__.formatStreamPart)(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/streamable.tsx\n\n\nfunction createStreamableUI(initialValue) {\n    const innerStreamable = createStreamableValue(initialValue);\n    let closed = false;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": UI stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    const streamable2 = {\n        value: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_11__.InternalStreamableUIClient, {\n            s: innerStreamable.value\n        }),\n        update (value) {\n            assertStream(\".update()\");\n            innerStreamable.update(value);\n            warnUnclosedStream();\n            return streamable2;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            innerStreamable.append(value);\n            warnUnclosedStream();\n            return streamable2;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            innerStreamable.error(error);\n            return streamable2;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            if (args.length) {\n                innerStreamable.done(args[0]);\n                return streamable2;\n            }\n            innerStreamable.done();\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\nvar STREAMABLE_VALUE_INTERNAL_LOCK = Symbol(\"streamable.value.lock\");\nfunction createStreamableValue(initialValue) {\n    const isReadableStream = initialValue instanceof ReadableStream || typeof initialValue === \"object\" && initialValue !== null && \"getReader\" in initialValue && typeof initialValue.getReader === \"function\" && \"locked\" in initialValue && typeof initialValue.locked === \"boolean\";\n    if (!isReadableStream) {\n        return createStreamableValueImpl(initialValue);\n    }\n    const streamableValue = createStreamableValueImpl();\n    streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n    (async ()=>{\n        try {\n            const reader = initialValue.getReader();\n            while(true){\n                const { value, done } = await reader.read();\n                if (done) {\n                    break;\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n                if (typeof value === \"string\") {\n                    streamableValue.append(value);\n                } else {\n                    streamableValue.update(value);\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n            }\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.done();\n        } catch (e) {\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.error(e);\n        }\n    })();\n    return streamableValue;\n}\nfunction createStreamableValueImpl(initialValue) {\n    let closed = false;\n    let locked = false;\n    let resolvable = createResolvablePromise();\n    let currentValue = initialValue;\n    let currentError;\n    let currentPromise = resolvable.promise;\n    let currentPatchValue;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": Value stream is already closed.\");\n        }\n        if (locked) {\n            throw new Error(method + \": Value stream is locked and cannot be updated.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    function createWrapped(initialChunk) {\n        let init;\n        if (currentError !== void 0) {\n            init = {\n                error: currentError\n            };\n        } else {\n            if (currentPatchValue && !initialChunk) {\n                init = {\n                    diff: currentPatchValue\n                };\n            } else {\n                init = {\n                    curr: currentValue\n                };\n            }\n        }\n        if (currentPromise) {\n            init.next = currentPromise;\n        }\n        if (initialChunk) {\n            init.type = STREAMABLE_VALUE_TYPE;\n        }\n        return init;\n    }\n    function updateValueStates(value) {\n        currentPatchValue = void 0;\n        if (typeof value === \"string\") {\n            if (typeof currentValue === \"string\") {\n                if (value.startsWith(currentValue)) {\n                    currentPatchValue = [\n                        0,\n                        value.slice(currentValue.length)\n                    ];\n                }\n            }\n        }\n        currentValue = value;\n    }\n    const streamable2 = {\n        set [STREAMABLE_VALUE_INTERNAL_LOCK] (state){\n            locked = state;\n        },\n        get value () {\n            return createWrapped(true);\n        },\n        update (value) {\n            assertStream(\".update()\");\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            updateValueStates(value);\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            if (typeof value !== \"string\" && !/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_4__.isValidElement)(value)) {\n                throw new Error(`.append(): The value type can't be appended to the stream. Received: ${typeof value}`);\n            }\n            if (typeof currentValue === \"undefined\") {\n                currentPatchValue = void 0;\n                currentValue = value;\n            } else if (typeof currentValue === \"string\") {\n                if (typeof value === \"string\") {\n                    currentPatchValue = [\n                        0,\n                        value\n                    ];\n                    currentValue = currentValue + value;\n                } else {\n                    currentPatchValue = [\n                        1,\n                        value\n                    ];\n                    currentValue = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.Fragment, {\n                        children: [\n                            currentValue,\n                            value\n                        ]\n                    });\n                }\n            } else if (/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_4__.isValidElement)(currentValue)) {\n                currentPatchValue = [\n                    1,\n                    value\n                ];\n                currentValue = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.Fragment, {\n                    children: [\n                        currentValue,\n                        value\n                    ]\n                });\n            } else {\n                throw new Error(`.append(): The current value doesn't support appending data. Type: ${typeof currentValue}`);\n            }\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentError = error;\n            currentPromise = void 0;\n            resolvable.resolve({\n                error\n            });\n            return streamable2;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentPromise = void 0;\n            if (args.length) {\n                updateValueStates(args[0]);\n                resolvable.resolve(createWrapped());\n                return streamable2;\n            }\n            resolvable.resolve({});\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\nfunction render(options) {\n    const ui = createStreamableUI(options.initial);\n    const text = options.text ? options.text : ({ content })=>content;\n    const functions = options.functions ? Object.entries(options.functions).map(([name, { description, parameters }])=>{\n        return {\n            name,\n            description,\n            parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(parameters)\n        };\n    }) : void 0;\n    const tools = options.tools ? Object.entries(options.tools).map(([name, { description, parameters }])=>{\n        return {\n            type: \"function\",\n            function: {\n                name,\n                description,\n                parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(parameters)\n            }\n        };\n    }) : void 0;\n    if (functions && tools) {\n        throw new Error(\"You can't have both functions and tools defined. Please choose one or the other.\");\n    }\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    (async ()=>{\n        let hasFunction = false;\n        let content = \"\";\n        consumeStream(OpenAIStream(await options.provider.chat.completions.create({\n            model: options.model,\n            messages: options.messages,\n            temperature: options.temperature,\n            stream: true,\n            ...functions ? {\n                functions\n            } : {},\n            ...tools ? {\n                tools\n            } : {}\n        }), {\n            ...functions ? {\n                async experimental_onFunctionCall (functionCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    handleRender(functionCallPayload.arguments, (_b = (_a = options.functions) == null ? void 0 : _a[functionCallPayload.name]) == null ? void 0 : _b.render, ui);\n                }\n            } : {},\n            ...tools ? {\n                async experimental_onToolCall (toolCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    for (const tool of toolCallPayload.tools){\n                        handleRender(tool.func.arguments, (_b = (_a = options.tools) == null ? void 0 : _a[tool.func.name]) == null ? void 0 : _b.render, ui);\n                    }\n                }\n            } : {},\n            onText (chunk) {\n                content += chunk;\n                handleRender({\n                    content,\n                    done: false,\n                    delta: chunk\n                }, text, ui);\n            },\n            async onFinal () {\n                if (hasFunction) {\n                    await finished;\n                    ui.done();\n                    return;\n                }\n                handleRender({\n                    content,\n                    done: true\n                }, text, ui);\n                await finished;\n                ui.done();\n            }\n        }));\n    })();\n    return ui.value;\n}\n// rsc/stream-ui/stream-ui.tsx\n\n\nvar defaultTextRenderer = ({ content })=>content;\nasync function streamUI({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, initial, text, ...settings }) {\n    if (typeof model === \"string\") {\n        throw new Error(\"`model` cannot be a string in `streamUI`. Use the actual model instance instead.\");\n    }\n    if (\"functions\" in settings) {\n        throw new Error(\"`functions` is not supported in `streamUI`, use `tools` instead.\");\n    }\n    if (\"provider\" in settings) {\n        throw new Error(\"`provider` is no longer needed in `streamUI`. Use `model` instead.\");\n    }\n    if (tools) {\n        for (const [name, tool] of Object.entries(tools)){\n            if (\"render\" in tool) {\n                throw new Error(\"Tool definition in `streamUI` should not have `render` property. Use `generate` instead. Found in tool: \" + name);\n            }\n        }\n    }\n    const ui = createStreamableUI(initial);\n    const textRender = text || defaultTextRenderer;\n    let finished;\n    async function handleRender(args, renderer, res, lastCall = false) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(...args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            if (lastCall) {\n                res.done(node);\n            } else {\n                res.update(node);\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                if (lastCall && done) {\n                    res.done(value2);\n                } else {\n                    res.update(value2);\n                }\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                if (lastCall && done) {\n                    res.done(value2);\n                } else {\n                    res.update(value2);\n                }\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            if (lastCall) {\n                res.done(value);\n            } else {\n                res.update(value);\n            }\n            resolvable.resolve(void 0);\n        }\n    }\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n    });\n    const result = await retry(()=>model.doStream({\n            mode: {\n                type: \"regular\",\n                ...prepareToolsAndToolChoice({\n                    tools,\n                    toolChoice\n                })\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: convertToLanguageModelPrompt(validatedPrompt),\n            abortSignal\n        }));\n    const [stream, forkedStream] = result.stream.tee();\n    (async ()=>{\n        try {\n            let content = \"\";\n            let hasToolCall = false;\n            const reader = forkedStream.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                switch(value.type){\n                    case \"text-delta\":\n                        {\n                            content += value.textDelta;\n                            handleRender([\n                                {\n                                    content,\n                                    done: false,\n                                    delta: value.textDelta\n                                }\n                            ], textRender, ui);\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            hasToolCall = true;\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const toolName = value.toolName;\n                            if (!tools) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.NoSuchToolError({\n                                    toolName\n                                });\n                            }\n                            const tool = tools[toolName];\n                            if (!tool) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.NoSuchToolError({\n                                    toolName,\n                                    availableTools: Object.keys(tools)\n                                });\n                            }\n                            hasToolCall = true;\n                            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_6__.safeParseJSON)({\n                                text: value.args,\n                                schema: tool.parameters\n                            });\n                            if (parseResult.success === false) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidToolArgumentsError({\n                                    toolName,\n                                    toolArgs: value.args,\n                                    cause: parseResult.error\n                                });\n                            }\n                            handleRender([\n                                parseResult.value,\n                                {\n                                    toolName,\n                                    toolCallId: value.toolCallId\n                                }\n                            ], tool.generate, ui, true);\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            throw value.error;\n                        }\n                    case \"finish\":\n                        {}\n                }\n            }\n            if (hasToolCall) {\n                await finished;\n            } else {\n                handleRender([\n                    {\n                        content,\n                        done: true\n                    }\n                ], textRender, ui, true);\n                await finished;\n            }\n        } catch (error) {\n            ui.error(error);\n        }\n    })();\n    return {\n        ...result,\n        stream,\n        value: ui.value\n    };\n}\n// rsc/provider.tsx\n\n\n\nvar innerAction = (0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(\"b521eb735db1932b4b53160e146fff6850ebefc7\", $$ACTION_0);\nasync function $$ACTION_0({ action, options }, state1, ...args) {\n    return await withAIState({\n        state: state1,\n        options\n    }, async ()=>{\n        const result = await action(...args);\n        sealMutableAIState();\n        return [\n            getAIStateDeltaPromise(),\n            result\n        ];\n    });\n}\nfunction wrapAction(action, options) {\n    return innerAction.bind(null, {\n        action,\n        options\n    });\n}\nfunction createAI({ actions, initialAIState, initialUIState, onSetAIState, onGetUIState }) {\n    const wrappedActions = {};\n    for(const name in actions){\n        wrappedActions[name] = wrapAction(actions[name], {\n            onSetAIState\n        });\n    }\n    const wrappedSyncUIState = onGetUIState ? wrapAction(onGetUIState, {}) : void 0;\n    const AI = async (props)=>{\n        var _a, _b;\n        if (\"useState\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_4___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_4___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_4__, 2)))) {\n            throw new Error(\"This component can only be used inside Server Components.\");\n        }\n        let uiState = (_a = props.initialUIState) != null ? _a : initialUIState;\n        let aiState = (_b = props.initialAIState) != null ? _b : initialAIState;\n        let aiStateDelta = void 0;\n        if (wrappedSyncUIState) {\n            const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n            if (newUIState !== void 0) {\n                aiStateDelta = newAIStateDelta;\n                uiState = newUIState;\n            }\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_11__.InternalAIProvider, {\n            wrappedActions,\n            wrappedSyncUIState,\n            initialUIState: uiState,\n            initialAIState: aiState,\n            initialAIStatePatch: aiStateDelta,\n            children: props.children\n        });\n    };\n    return AI;\n}\n //# sourceMappingURL=rsc-server.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNlcnZlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ0g7O0FDRHhCLFNBQVNFO0lBQ2QsSUFBSUMsU0FBNkJDO0lBQ2pDLE1BQU1DLFVBQVUsSUFBSUMsUUFBVyxDQUFDQyxLQUFLQztRQUNuQ0wsVUFBVUk7UUFDVkgsU0FBU0k7SUFDWDtJQUNBLE9BQU87UUFDTEg7UUFDQUY7UUFDQUM7SUFDRjtBQUNGO0FBRU8sSUFBTUssYUFBYSxDQUFDQyxJQUN6QixPQUFPQSxNQUFNO0FBRVIsSUFBTUMsZ0JBQWdCLE9BQU9DO0lBQ2xDLE1BQU1DLFNBQVNELE9BQU9FLFNBQUE7SUFDdEIsTUFBTyxLQUFNO1FBQ1gsTUFBTSxFQUFFQyxJQUFBLEVBQUssR0FBSSxNQUFNRixPQUFPRyxJQUFBO1FBQzlCLElBQUlELE1BQU07SUFDWjtBQUNGOztBRFRBLElBQU1FLHNCQUFzQixJQUFJakIsMERBQWlCQTtBQVNqRCxTQUFTa0IsdUJBQXVCQyxPQUFBO0lBQzlCLE1BQU1DLFFBQVFILG9CQUFvQkksUUFBQTtJQUNsQyxJQUFJLENBQUNELE9BQU87UUFDVixNQUFNLElBQUlFLE1BQU1IO0lBQ2xCO0lBQ0EsT0FBT0M7QUFDVDtBQUVPLFNBQVNHLFlBQ2QsRUFBRUMsT0FBQUEsTUFBQSxFQUFPQyxPQUFBLEVBQVEsRUFDakJDLEVBQUE7SUFFQSxPQUFPVCxvQkFBb0JVLEdBQUEsQ0FDekI7UUFDRUMsY0FBY0o7UUFDZEssZUFBZUw7UUFDZk0sUUFBUTtRQUNSTDtJQUNGLEdBQ0FDO0FBRUo7QUFFTyxTQUFTSztJQUNkLE1BQU1YLFFBQVFGLHVCQUF1QjtJQUNyQyxPQUFPRSxNQUFNWSxvQkFBQTtBQUNmO0FBS08sU0FBU0M7SUFDZCxNQUFNYixRQUFRRix1QkFBdUI7SUFDckNFLE1BQU1VLE1BQUEsR0FBUztBQUNqQjtBQWdCQSxTQUFTSSxXQUFBLEdBQ0pDLElB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VSxZQUFBLEVBQ0Y7SUEwQ0UsTUFBTUMsaUJBQXVDLENBQUM7SUFDOUMsVUFBV3hSLFFBQVFvUixRQUFTO1FBQzFCSSxjQUFBLENBQWV4UixLQUFJLEdBQUlpUixXQUFXRyxPQUFBLENBQVFwUixLQUFJLEVBQUc7WUFDL0NuRDtRQUNGO0lBQ0Y7SUFFQSxNQUFNNFUscUJBQXFCRixlQUN2Qk4sV0FBV00sY0FBYyxDQUFDLEtBQzFCO0lBRUosTUFBTUcsS0FBNEMsT0FBTUM7UUFoSDFELElBQUFoVixJQUFBQztRQWlISSxJQUFJLHVNQUFtQmlVLEVBQUU7WUFJdkIsTUFBTSxJQUFJdlYsTUFDUjtRQUVKO1FBRUEsSUFBSXNXLFVBQUEsQ0FBVWpWLEtBQUFnVixNQUFNTCxjQUFBLEtBQU4sT0FBQTNVLEtBQXdCMlU7UUFDdEMsSUFBSU8sVUFBQSxDQUFValYsS0FBQStVLE1BQU1OLGNBQUEsS0FBTixPQUFBelUsS0FBd0J5VTtRQUN0QyxJQUFJUyxlQUFlO1FBRW5CLElBQUlMLG9CQUFvQjtZQUN0QixNQUFNLENBQUNNLGlCQUFpQkMsV0FBVSxHQUFJLE1BQU1QLG1CQUFtQkk7WUFDL0QsSUFBSUcsZUFBZSxRQUFXO2dCQUM1QkYsZUFBZUM7Z0JBQ2ZILFVBQVVJO1lBQ1o7UUFDRjtRQUVBLE9BQ0UsZ0JBQUE5Rix1REFBQUEsQ0FBQzRFLGdFQUFrQkEsRUFBbEI7WUFDQ1U7WUFDQUM7WUFDQUgsZ0JBQWdCTTtZQUNoQlAsZ0JBQWdCUTtZQUNoQkkscUJBQXFCSDtZQUVwQjVELFVBQUF5RCxNQUFNekQsUUFBQTtRQUFBO0lBR2I7SUFFQSxPQUFPd0Q7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi9haS1zdGF0ZS50c3g/MzgwMCIsIndlYnBhY2s6Ly93ZWIvLi4vdXRpbHMudHN4PzdhMmUiLCJ3ZWJwYWNrOi8vd2ViLy4uL3N0cmVhbWFibGUudHN4PzY5MWYiLCJ3ZWJwYWNrOi8vd2ViLy4uLy4uL2NvcmUvdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHM/ZjBkMCIsIndlYnBhY2s6Ly93ZWIvLi4vLi4vY29yZS91dGlsL2RlbGF5LnRzP2ExZTciLCJ3ZWJwYWNrOi8vd2ViLy4uLy4uL2NvcmUvdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUudHM/OTU0NSIsIndlYnBhY2s6Ly93ZWIvLi4vLi4vY29yZS9wcm9tcHQvZGF0YS1jb250ZW50LnRzP2U5MmYiLCJ3ZWJwYWNrOi8vd2ViLy4uLy4uL2NvcmUvcHJvbXB0L2ludmFsaWQtbWVzc2FnZS1yb2xlLWVycm9yLnRzPzg5NzAiLCJ3ZWJwYWNrOi8vd2ViLy4uLy4uL2NvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0LnRzPzcxNzQiLCJ3ZWJwYWNrOi8vd2ViLy4uLy4uL2NvcmUvcHJvbXB0L2dldC12YWxpZGF0ZWQtcHJvbXB0LnRzPzU3OGUiLCJ3ZWJwYWNrOi8vd2ViLy4uLy4uL2NvcmUvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncy50cz9kNThjIiwid2VicGFjazovL3dlYi8uLi8uLi9jb3JlL3V0aWwvY29udmVydC16b2QtdG8tanNvbi1zY2hlbWEudHM/MDBmZiIsIndlYnBhY2s6Ly93ZWIvLi4vLi4vY29yZS91dGlsL2lzLW5vbi1lbXB0eS1vYmplY3QudHM/Y2FjOCIsIndlYnBhY2s6Ly93ZWIvLi4vLi4vY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHM/MThhMCIsIndlYnBhY2s6Ly93ZWIvLi4vLi4vc3RyZWFtcy9haS1zdHJlYW0udHM/NDg1NCIsIndlYnBhY2s6Ly93ZWIvLi4vLi4vc3RyZWFtcy9zdHJlYW0tZGF0YS50cz82NzMwIiwid2VicGFjazovL3dlYi8uLi8uLi9zdHJlYW1zL29wZW5haS1zdHJlYW0udHM/YjJiZCIsIndlYnBhY2s6Ly93ZWIvLi4vY29uc3RhbnRzLnRzP2FiNzIiLCJ3ZWJwYWNrOi8vd2ViLy4uL3N0cmVhbS11aS9zdHJlYW0tdWkudHN4PzFjY2EiLCJ3ZWJwYWNrOi8vd2ViLy4uL3Byb3ZpZGVyLnRzeD8zMGViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlIH0gZnJvbSAnYXN5bmNfaG9va3MnO1xuaW1wb3J0ICogYXMganNvbmRpZmZwYXRjaCBmcm9tICdqc29uZGlmZnBhdGNoJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlLCBpc0Z1bmN0aW9uIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7XG4gIEFJUHJvdmlkZXIsXG4gIEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zLFxuICBJbmZlckFJU3RhdGUsXG4gIE11dGFibGVBSVN0YXRlLFxuICBWYWx1ZU9yVXBkYXRlcixcbn0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgbXVsdGlwbGUgQUkgcmVxdWVzdHMgZ2V0IGluIGNvbmN1cnJlbnRseSwgZm9yIGRpZmZlcmVudFxuLy8gQUkgaW5zdGFuY2VzLiBTbyBBTFMgaXMgbmVjZXNzYXJ5IGhlcmUgZm9yIGEgc2ltcGxlciBBUEkuXG5jb25zdCBhc3luY0FJU3RhdGVTdG9yYWdlID0gbmV3IEFzeW5jTG9jYWxTdG9yYWdlPHtcbiAgY3VycmVudFN0YXRlOiBhbnk7XG4gIG9yaWdpbmFsU3RhdGU6IGFueTtcbiAgc2VhbGVkOiBib29sZWFuO1xuICBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucztcbiAgbXV0YXRpb25EZWx0YVByb21pc2U/OiBQcm9taXNlPGFueT47XG4gIG11dGF0aW9uRGVsdGFSZXNvbHZlPzogKHY6IGFueSkgPT4gdm9pZDtcbn0+KCk7XG5cbmZ1bmN0aW9uIGdldEFJU3RhdGVTdG9yZU9yVGhyb3cobWVzc2FnZTogc3RyaW5nKSB7XG4gIGNvbnN0IHN0b3JlID0gYXN5bmNBSVN0YXRlU3RvcmFnZS5nZXRTdG9yZSgpO1xuICBpZiAoIXN0b3JlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiBzdG9yZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhBSVN0YXRlPFMsIFQ+KFxuICB7IHN0YXRlLCBvcHRpb25zIH06IHsgc3RhdGU6IFM7IG9wdGlvbnM6IEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zIH0sXG4gIGZuOiAoKSA9PiBULFxuKTogVCB7XG4gIHJldHVybiBhc3luY0FJU3RhdGVTdG9yYWdlLnJ1bihcbiAgICB7XG4gICAgICBjdXJyZW50U3RhdGU6IHN0YXRlLFxuICAgICAgb3JpZ2luYWxTdGF0ZTogc3RhdGUsXG4gICAgICBzZWFsZWQ6IGZhbHNlLFxuICAgICAgb3B0aW9ucyxcbiAgICB9LFxuICAgIGZuLFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KCdJbnRlcm5hbCBlcnJvciBvY2N1cnJlZC4nKTtcbiAgcmV0dXJuIHN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlO1xufVxuXG4vLyBJbnRlcm5hbCBtZXRob2QuIFRoaXMgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIEFJIEFjdGlvbiBoYXMgYmVlbiByZXR1cm5lZFxuLy8gYW5kIHlvdSBjYW4gbm8gbG9uZ2VyIGNhbGwgYGdldE11dGFibGVBSVN0YXRlKClgIGluc2lkZSBhbnkgYXN5bmMgY2FsbGJhY2tzXG4vLyBjcmVhdGVkIGJ5IHRoYXQgQWN0aW9uLlxuZXhwb3J0IGZ1bmN0aW9uIHNlYWxNdXRhYmxlQUlTdGF0ZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KCdJbnRlcm5hbCBlcnJvciBvY2N1cnJlZC4nKTtcbiAgc3RvcmUuc2VhbGVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgQUkgc3RhdGUuXG4gKiBJZiBga2V5YCBpcyBwcm92aWRlZCwgaXQgd2lsbCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQga2V5IGluIHRoZVxuICogQUkgc3RhdGUsIGlmIGl0J3MgYW4gb2JqZWN0LiBJZiBpdCdzIG5vdCBhbiBvYmplY3QsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKlxuICogQGV4YW1wbGUgY29uc3Qgc3RhdGUgPSBnZXRBSVN0YXRlKCkgLy8gR2V0IHRoZSBlbnRpcmUgQUkgc3RhdGVcbiAqIEBleGFtcGxlIGNvbnN0IGZpZWxkID0gZ2V0QUlTdGF0ZSgna2V5JykgLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUga2V5XG4gKi9cbmZ1bmN0aW9uIGdldEFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpOiBSZWFkb25seTxcbiAgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XG4+O1xuZnVuY3Rpb24gZ2V0QUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICBrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pixcbik6IFJlYWRvbmx5PEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XT47XG5mdW5jdGlvbiBnZXRBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIC4uLmFyZ3M6IFtdIHwgW2tleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XVxuKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhcbiAgICAnYGdldEFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhbiBBSSBBY3Rpb24uJyxcbiAgKTtcblxuICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICBpZiAodHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW4ndCBnZXQgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAga2V5LFxuICAgICAgICApfVwiIGZpZWxkIGZyb20gdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlW2tleSBhcyBrZXlvZiB0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlXTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBtdXRhYmxlIEFJIHN0YXRlLiBOb3RlIHRoYXQgeW91IG11c3QgY2FsbCBgLmRvbmUoKWAgd2hlbiBmaW5pc2hpbmdcbiAqIHVwZGF0aW5nIHRoZSBBSSBzdGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCBzdGF0ZSA9IGdldE11dGFibGVBSVN0YXRlKClcbiAqIHN0YXRlLnVwZGF0ZSh7IC4uLnN0YXRlLmdldCgpLCBrZXk6ICd2YWx1ZScgfSlcbiAqIHN0YXRlLnVwZGF0ZSgoY3VycmVudFN0YXRlKSA9PiAoeyAuLi5jdXJyZW50U3RhdGUsIGtleTogJ3ZhbHVlJyB9KSlcbiAqIHN0YXRlLmRvbmUoKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3Qgc3RhdGUgPSBnZXRNdXRhYmxlQUlTdGF0ZSgpXG4gKiBzdGF0ZS5kb25lKHsgLi4uc3RhdGUuZ2V0KCksIGtleTogJ3ZhbHVlJyB9KSAvLyBEb25lIHdpdGggYSBuZXcgc3RhdGVcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCk6IE11dGFibGVBSVN0YXRlPFxuICBJbmZlckFJU3RhdGU8QUksIGFueT5cbj47XG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICBrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pixcbik6IE11dGFibGVBSVN0YXRlPEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XT47XG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICAuLi5hcmdzOiBbXSB8IFtrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pl1cbikge1xuICB0eXBlIEFJU3RhdGUgPSBJbmZlckFJU3RhdGU8QUksIGFueT47XG4gIHR5cGUgQUlTdGF0ZVdpdGhLZXkgPSB0eXBlb2YgYXJncyBleHRlbmRzIFtrZXk6IGtleW9mIEFJU3RhdGVdXG4gICAgPyBBSVN0YXRlWyh0eXBlb2YgYXJncylbMF1dXG4gICAgOiBBSVN0YXRlO1xuICB0eXBlIE5ld1N0YXRlT3JVcGRhdGVyID0gVmFsdWVPclVwZGF0ZXI8QUlTdGF0ZVdpdGhLZXk+O1xuXG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhcbiAgICAnYGdldE11dGFibGVBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYW4gQUkgQWN0aW9uLicsXG4gICk7XG5cbiAgaWYgKHN0b3JlLnNlYWxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYGdldE11dGFibGVBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gYW4gQUkgQWN0aW9uLiBQbGVhc2UgbW92ZSBpdCB0byB0aGUgdG9wIGxldmVsIG9mIHRoZSBBY3Rpb24ncyBmdW5jdGlvbiBib2R5LlwiLFxuICAgICk7XG4gIH1cblxuICBpZiAoIXN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlKSB7XG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlID0gcHJvbWlzZTtcbiAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUmVzb2x2ZSA9IHJlc29sdmU7XG4gIH1cblxuICBmdW5jdGlvbiBkb1VwZGF0ZShuZXdTdGF0ZTogTmV3U3RhdGVPclVwZGF0ZXIsIGRvbmU6IGJvb2xlYW4pIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgY2FuJ3QgbW9kaWZ5IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICl9XCIgZmllbGQgb2YgdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24obmV3U3RhdGUpKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSA9IG5ld1N0YXRlKHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZShzdG9yZS5jdXJyZW50U3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSA9IG5ld1N0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RvcmUub3B0aW9ucy5vblNldEFJU3RhdGU/Lih7XG4gICAgICBrZXk6IGFyZ3MubGVuZ3RoID4gMCA/IGFyZ3NbMF0gOiB1bmRlZmluZWQsXG4gICAgICBzdGF0ZTogc3RvcmUuY3VycmVudFN0YXRlLFxuICAgICAgZG9uZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IG11dGFibGVTdGF0ZSA9IHtcbiAgICBnZXQ6ICgpID0+IHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFlvdSBjYW4ndCBnZXQgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICl9XCIgZmllbGQgZnJvbSB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGVba2V5XSBhcyBSZWFkb25seTxBSVN0YXRlV2l0aEtleT47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGUgYXMgUmVhZG9ubHk8QUlTdGF0ZT47XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShuZXdBSVN0YXRlOiBOZXdTdGF0ZU9yVXBkYXRlcikge1xuICAgICAgZG9VcGRhdGUobmV3QUlTdGF0ZSwgZmFsc2UpO1xuICAgIH0sXG4gICAgZG9uZTogZnVuY3Rpb24gZG9uZSguLi5kb25lQXJnczogW10gfCBbTmV3U3RhdGVPclVwZGF0ZXJdKSB7XG4gICAgICBpZiAoZG9uZUFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBkb1VwZGF0ZShkb25lQXJnc1swXSBhcyBOZXdTdGF0ZU9yVXBkYXRlciwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlbHRhID0ganNvbmRpZmZwYXRjaC5kaWZmKHN0b3JlLm9yaWdpbmFsU3RhdGUsIHN0b3JlLmN1cnJlbnRTdGF0ZSk7XG4gICAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUmVzb2x2ZSEoZGVsdGEpO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIG11dGFibGVTdGF0ZTtcbn1cblxuZXhwb3J0IHsgZ2V0QUlTdGF0ZSwgZ2V0TXV0YWJsZUFJU3RhdGUgfTtcbiIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTxUID0gYW55PigpIHtcbiAgbGV0IHJlc29sdmU6ICh2YWx1ZTogVCkgPT4gdm9pZCwgcmVqZWN0OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWQ7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxUPigocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICByZXNvbHZlOiByZXNvbHZlISxcbiAgICByZWplY3Q6IHJlamVjdCEsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHg6IHVua25vd24pOiB4IGlzIEZ1bmN0aW9uID0+XG4gIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgY29uc3VtZVN0cmVhbSA9IGFzeW5jIChzdHJlYW06IFJlYWRhYmxlU3RyZWFtKSA9PiB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIGJyZWFrO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgdHlwZSBSZWFjdE5vZGUsIGlzVmFsaWRFbGVtZW50LCBSZWFjdEVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdHlwZSBPcGVuQUkgZnJvbSAnb3BlbmFpJztcbmltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuaW1wb3J0IHpvZFRvSnNvblNjaGVtYSBmcm9tICd6b2QtdG8tanNvbi1zY2hlbWEnO1xuXG4vLyBUT0RPOiBUaGlzIG5lZWRzIHRvIGJlIGV4dGVybmFsaXplZC5cbmltcG9ydCB7IE9wZW5BSVN0cmVhbSB9IGZyb20gJy4uL3N0cmVhbXMnO1xuXG5pbXBvcnQge1xuICBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUsXG4gIERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FLFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSwgY29uc3VtZVN0cmVhbSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBTdHJlYW1hYmxlUGF0Y2gsIFN0cmVhbWFibGVWYWx1ZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgSW50ZXJuYWxTdHJlYW1hYmxlVUlDbGllbnQgfSBmcm9tICcuL3JzYy1zaGFyZWQubWpzJztcblxuLy8gSXQncyBuZWNlc3NhcnkgdG8gZGVmaW5lIHRoZSB0eXBlIG1hbnVhbGx5IGhlcmUsIG90aGVyd2lzZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4vLyB3aWxsIG5vdCBiZSBhYmxlIHRvIGluZmVyIHRoZSBjb3JyZWN0IHJldHVybiB0eXBlIGFzIGl0J3MgY2lyY3VsYXIuXG50eXBlIFN0cmVhbWFibGVVSVdyYXBwZXIgPSB7XG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUgVUkuIFRoaXMgY2FuIGJlIHJldHVybmVkIGZyb20gYSBTZXJ2ZXIgQWN0aW9uIGFuZCByZWNlaXZlZCBieSB0aGUgY2xpZW50LlxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IFJlYWN0LlJlYWN0Tm9kZTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCBVSSBub2RlLiBJdCB0YWtlcyBhIG5ldyBVSSBub2RlIGFuZCByZXBsYWNlcyB0aGUgb2xkIG9uZS5cbiAgICovXG4gIHVwZGF0ZSh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKTogU3RyZWFtYWJsZVVJV3JhcHBlcjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBhcHBlbmQgYSBuZXcgVUkgbm9kZSB0byB0aGUgZW5kIG9mIHRoZSBvbGQgb25lLlxuICAgKiBPbmNlIGFwcGVuZGVkIGEgbmV3IFVJIG5vZGUsIHRoZSBwcmV2aW91cyBVSSBub2RlIGNhbm5vdCBiZSB1cGRhdGVkIGFueW1vcmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSSg8ZGl2PmhlbGxvPC9kaXY+KVxuICAgKiB1aS5hcHBlbmQoPGRpdj53b3JsZDwvZGl2PilcbiAgICpcbiAgICogLy8gVGhlIFVJIG5vZGUgd2lsbCBiZTpcbiAgICogLy8gPD5cbiAgICogLy8gICA8ZGl2PmhlbGxvPC9kaXY+XG4gICAqIC8vICAgPGRpdj53b3JsZDwvZGl2PlxuICAgKiAvLyA8Lz5cbiAgICogYGBgXG4gICAqL1xuICBhcHBlbmQodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2lnbmFsIHRoYXQgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIFVJIHN0cmVhbS5cbiAgICogSXQgd2lsbCBiZSB0aHJvd24gb24gdGhlIGNsaWVudCBzaWRlIGFuZCBjYXVnaHQgYnkgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgY29tcG9uZW50LlxuICAgKi9cbiAgZXJyb3IoZXJyb3I6IGFueSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIG1hcmtzIHRoZSBVSSBub2RlIGFzIGZpbmFsaXplZC4gWW91IGNhbiBlaXRoZXIgY2FsbCBpdCB3aXRob3V0IGFueSBwYXJhbWV0ZXJzIG9yIHdpdGggYSBuZXcgVUkgbm9kZSBhcyB0aGUgZmluYWwgc3RhdGUuXG4gICAqIE9uY2UgY2FsbGVkLCB0aGUgVUkgbm9kZSBjYW5ub3QgYmUgdXBkYXRlZCBvciBhcHBlbmRlZCBhbnltb3JlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhbHdheXMgKipyZXF1aXJlZCoqIHRvIGJlIGNhbGxlZCwgb3RoZXJ3aXNlIHRoZSByZXNwb25zZSB3aWxsIGJlIHN0dWNrIGluIGEgbG9hZGluZyBzdGF0ZS5cbiAgICovXG4gIGRvbmUoLi4uYXJnczogW1JlYWN0LlJlYWN0Tm9kZV0gfCBbXSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHBpZWNlIG9mIGNoYW5nYWJsZSBVSSB0aGF0IGNhbiBiZSBzdHJlYW1lZCB0byB0aGUgY2xpZW50LlxuICogT24gdGhlIGNsaWVudCBzaWRlLCBpdCBjYW4gYmUgcmVuZGVyZWQgYXMgYSBub3JtYWwgUmVhY3Qgbm9kZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtYWJsZVVJKGluaXRpYWxWYWx1ZT86IFJlYWN0LlJlYWN0Tm9kZSkge1xuICBjb25zdCBpbm5lclN0cmVhbWFibGUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWU8UmVhY3QuUmVhY3ROb2RlPihpbml0aWFsVmFsdWUpO1xuXG4gIGxldCBjbG9zZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBhc3NlcnRTdHJlYW0obWV0aG9kOiBzdHJpbmcpIHtcbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJzogVUkgc3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkLicpO1xuICAgIH1cbiAgfVxuXG4gIGxldCB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHdhcm5VbmNsb3NlZFN0cmVhbSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgd2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUaGUgc3RyZWFtYWJsZSBVSSBoYXMgYmVlbiBzbG93IHRvIHVwZGF0ZS4gVGhpcyBtYXkgYmUgYSBidWcgb3IgYSBwZXJmb3JtYW5jZSBpc3N1ZSBvciB5b3UgZm9yZ290IHRvIGNhbGwgYC5kb25lKClgLicsXG4gICAgICAgICk7XG4gICAgICB9LCBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSk7XG4gICAgfVxuICB9XG4gIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gIGNvbnN0IHN0cmVhbWFibGU6IFN0cmVhbWFibGVVSVdyYXBwZXIgPSB7XG4gICAgdmFsdWU6IDxJbnRlcm5hbFN0cmVhbWFibGVVSUNsaWVudCBzPXtpbm5lclN0cmVhbWFibGUudmFsdWV9IC8+LFxuICAgIHVwZGF0ZSh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy51cGRhdGUoKScpO1xuXG4gICAgICBpbm5lclN0cmVhbWFibGUudXBkYXRlKHZhbHVlKTtcbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGFwcGVuZCh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5hcHBlbmQoKScpO1xuXG4gICAgICBpbm5lclN0cmVhbWFibGUuYXBwZW5kKHZhbHVlKTtcbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGVycm9yKGVycm9yOiBhbnkpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmVycm9yKCknKTtcblxuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgaW5uZXJTdHJlYW1hYmxlLmVycm9yKGVycm9yKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBkb25lKC4uLmFyZ3M6IFtdIHwgW1JlYWN0LlJlYWN0Tm9kZV0pIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmRvbmUoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgaW5uZXJTdHJlYW1hYmxlLmRvbmUoYXJnc1swXSk7XG4gICAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgICAgfVxuXG4gICAgICBpbm5lclN0cmVhbWFibGUuZG9uZSgpO1xuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gc3RyZWFtYWJsZTtcbn1cblxuY29uc3QgU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLID0gU3ltYm9sKCdzdHJlYW1hYmxlLnZhbHVlLmxvY2snKTtcblxuLyoqXG4gKiBDcmVhdGUgYSB3cmFwcGVkLCBjaGFuZ2FibGUgdmFsdWUgdGhhdCBjYW4gYmUgc3RyZWFtZWQgdG8gdGhlIGNsaWVudC5cbiAqIE9uIHRoZSBjbGllbnQgc2lkZSwgdGhlIHZhbHVlIGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGhlIHJlYWRTdHJlYW1hYmxlVmFsdWUoKSBBUEkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWFibGVWYWx1ZTxUID0gYW55LCBFID0gYW55PihcbiAgaW5pdGlhbFZhbHVlPzogVCB8IFJlYWRhYmxlU3RyZWFtPFQ+LFxuKSB7XG4gIGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPVxuICAgIGluaXRpYWxWYWx1ZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtIHx8XG4gICAgKHR5cGVvZiBpbml0aWFsVmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICBpbml0aWFsVmFsdWUgIT09IG51bGwgJiZcbiAgICAgICdnZXRSZWFkZXInIGluIGluaXRpYWxWYWx1ZSAmJlxuICAgICAgdHlwZW9mIGluaXRpYWxWYWx1ZS5nZXRSZWFkZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICdsb2NrZWQnIGluIGluaXRpYWxWYWx1ZSAmJlxuICAgICAgdHlwZW9mIGluaXRpYWxWYWx1ZS5sb2NrZWQgPT09ICdib29sZWFuJyk7XG5cbiAgaWYgKCFpc1JlYWRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVN0cmVhbWFibGVWYWx1ZUltcGw8VCwgRT4oaW5pdGlhbFZhbHVlKTtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbWFibGVWYWx1ZSA9IGNyZWF0ZVN0cmVhbWFibGVWYWx1ZUltcGw8VCwgRT4oKTtcblxuICAvLyBTaW5jZSB0aGUgc3RyZWFtYWJsZSB2YWx1ZSB3aWxsIGJlIGZyb20gYSByZWFkYWJsZSBzdHJlYW0sIGl0J3Mgbm90IGFsbG93ZWRcbiAgLy8gdG8gdXBkYXRlIHRoZSB2YWx1ZSBtYW51YWxseSBhcyB0aGF0IGludHJvZHVjZXMgcmFjZSBjb25kaXRpb25zIGFuZFxuICAvLyB1bmV4cGVjdGVkIGJlaGF2aW9yLlxuICAvLyBXZSBsb2NrIHRoZSB2YWx1ZSB0byBwcmV2ZW50IGFueSB1cGRhdGVzIGZyb20gdGhlIHVzZXIuXG4gIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gdHJ1ZTtcblxuICAoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDb25zdW1lIHRoZSByZWFkYWJsZSBzdHJlYW0gYW5kIHVwZGF0ZSB0aGUgdmFsdWUuXG4gICAgICBjb25zdCByZWFkZXIgPSBpbml0aWFsVmFsdWUuZ2V0UmVhZGVyKCk7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbmxvY2sgdGhlIHZhbHVlIHRvIGFsbG93IHVwZGF0ZXMuXG4gICAgICAgIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgc3RyZWFtYWJsZVZhbHVlLmFwcGVuZCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtYWJsZVZhbHVlLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9jayB0aGUgdmFsdWUgYWdhaW4uXG4gICAgICAgIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSBmYWxzZTtcbiAgICAgIHN0cmVhbWFibGVWYWx1ZS5kb25lKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSBmYWxzZTtcbiAgICAgIHN0cmVhbWFibGVWYWx1ZS5lcnJvcihlKTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgcmV0dXJuIHN0cmVhbWFibGVWYWx1ZTtcbn1cblxuLy8gSXQncyBuZWNlc3NhcnkgdG8gZGVmaW5lIHRoZSB0eXBlIG1hbnVhbGx5IGhlcmUsIG90aGVyd2lzZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4vLyB3aWxsIG5vdCBiZSBhYmxlIHRvIGluZmVyIHRoZSBjb3JyZWN0IHJldHVybiB0eXBlIGFzIGl0J3MgY2lyY3VsYXIuXG50eXBlIFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT4gPSB7XG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUuIFRoaXMgY2FuIGJlIHJldHVybmVkIGZyb20gYSBTZXJ2ZXIgQWN0aW9uIGFuZFxuICAgKiByZWNlaXZlZCBieSB0aGUgY2xpZW50LiBUbyByZWFkIHRoZSBzdHJlYW1lZCB2YWx1ZXMsIHVzZSB0aGVcbiAgICogYHJlYWRTdHJlYW1hYmxlVmFsdWVgIG9yIGB1c2VTdHJlYW1hYmxlVmFsdWVgIEFQSXMuXG4gICAqL1xuICByZWFkb25seSB2YWx1ZTogU3RyZWFtYWJsZVZhbHVlPFQsIEU+O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBjdXJyZW50IHZhbHVlIHdpdGggYSBuZXcgb25lLlxuICAgKi9cbiAgdXBkYXRlKHZhbHVlOiBUKTogU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBhcHBlbmQgYSBkZWx0YSBzdHJpbmcgdG8gdGhlIGN1cnJlbnQgdmFsdWUuIEl0XG4gICAqIHJlcXVpcmVzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlIHRvIGJlIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc3hcbiAgICogY29uc3Qgc3RyZWFtYWJsZSA9IGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgnaGVsbG8nKTtcbiAgICogc3RyZWFtYWJsZS5hcHBlbmQoJyB3b3JsZCcpO1xuICAgKlxuICAgKiAvLyBUaGUgdmFsdWUgd2lsbCBiZSAnaGVsbG8gd29ybGQnXG4gICAqIGBgYFxuICAgKi9cbiAgYXBwZW5kKHZhbHVlOiBUKTogU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzaWduYWwgdGhhdCB0aGVyZSBpcyBhbiBlcnJvciBpbiB0aGUgdmFsdWUgc3RyZWFtLlxuICAgKiBJdCB3aWxsIGJlIHRocm93biBvbiB0aGUgY2xpZW50IHNpZGUgd2hlbiBjb25zdW1lZCB2aWFcbiAgICogYHJlYWRTdHJlYW1hYmxlVmFsdWVgIG9yIGB1c2VTdHJlYW1hYmxlVmFsdWVgLlxuICAgKi9cbiAgZXJyb3IoZXJyb3I6IGFueSk6IFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT47XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIG1hcmtzIHRoZSB2YWx1ZSBhcyBmaW5hbGl6ZWQuIFlvdSBjYW4gZWl0aGVyIGNhbGwgaXQgd2l0aG91dFxuICAgKiBhbnkgcGFyYW1ldGVycyBvciB3aXRoIGEgbmV3IHZhbHVlIGFzIHRoZSBmaW5hbCBzdGF0ZS5cbiAgICogT25jZSBjYWxsZWQsIHRoZSB2YWx1ZSBjYW5ub3QgYmUgdXBkYXRlZCBvciBhcHBlbmRlZCBhbnltb3JlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhbHdheXMgKipyZXF1aXJlZCoqIHRvIGJlIGNhbGxlZCwgb3RoZXJ3aXNlIHRoZSByZXNwb25zZVxuICAgKiB3aWxsIGJlIHN0dWNrIGluIGEgbG9hZGluZyBzdGF0ZS5cbiAgICovXG4gIGRvbmUoLi4uYXJnczogW1RdIHwgW10pOiBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVGhpcyBpcyBhbiBpbnRlcm5hbCBsb2NrIHRvIHByZXZlbnQgdGhlIHZhbHVlIGZyb20gYmVpbmdcbiAgICogdXBkYXRlZCBieSB0aGUgdXNlci5cbiAgICovXG4gIFtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdOiBib29sZWFuO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbDxUID0gYW55LCBFID0gYW55Pihpbml0aWFsVmFsdWU/OiBUKSB7XG4gIGxldCBjbG9zZWQgPSBmYWxzZTtcbiAgbGV0IGxvY2tlZCA9IGZhbHNlO1xuICBsZXQgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPFN0cmVhbWFibGVWYWx1ZTxULCBFPj4oKTtcblxuICBsZXQgY3VycmVudFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBsZXQgY3VycmVudEVycm9yOiBFIHwgdW5kZWZpbmVkO1xuICBsZXQgY3VycmVudFByb21pc2U6IHR5cGVvZiByZXNvbHZhYmxlLnByb21pc2UgfCB1bmRlZmluZWQgPVxuICAgIHJlc29sdmFibGUucHJvbWlzZTtcbiAgbGV0IGN1cnJlbnRQYXRjaFZhbHVlOiBTdHJlYW1hYmxlUGF0Y2g7XG5cbiAgZnVuY3Rpb24gYXNzZXJ0U3RyZWFtKG1ldGhvZDogc3RyaW5nKSB7XG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICc6IFZhbHVlIHN0cmVhbSBpcyBhbHJlYWR5IGNsb3NlZC4nKTtcbiAgICB9XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBtZXRob2QgKyAnOiBWYWx1ZSBzdHJlYW0gaXMgbG9ja2VkIGFuZCBjYW5ub3QgYmUgdXBkYXRlZC4nLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBsZXQgd2FybmluZ1RpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgdW5kZWZpbmVkO1xuICBmdW5jdGlvbiB3YXJuVW5jbG9zZWRTdHJlYW0oKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnVGhlIHN0cmVhbWFibGUgVUkgaGFzIGJlZW4gc2xvdyB0byB1cGRhdGUuIFRoaXMgbWF5IGJlIGEgYnVnIG9yIGEgcGVyZm9ybWFuY2UgaXNzdWUgb3IgeW91IGZvcmdvdCB0byBjYWxsIGAuZG9uZSgpYC4nLFxuICAgICAgICApO1xuICAgICAgfSwgREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUpO1xuICAgIH1cbiAgfVxuICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVkKGluaXRpYWxDaHVuaz86IGJvb2xlYW4pOiBTdHJlYW1hYmxlVmFsdWU8VCwgRT4ge1xuICAgIC8vIFRoaXMgbWFrZXMgdGhlIHBheWxvYWQgbXVjaCBzbWFsbGVyIGlmIHRoZXJlJ3JlIG11dGF0aXZlIHVwZGF0ZXMgYmVmb3JlIHRoZSBmaXJzdCByZWFkLlxuICAgIGxldCBpbml0OiBQYXJ0aWFsPFN0cmVhbWFibGVWYWx1ZTxULCBFPj47XG5cbiAgICBpZiAoY3VycmVudEVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluaXQgPSB7IGVycm9yOiBjdXJyZW50RXJyb3IgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN1cnJlbnRQYXRjaFZhbHVlICYmICFpbml0aWFsQ2h1bmspIHtcbiAgICAgICAgaW5pdCA9IHsgZGlmZjogY3VycmVudFBhdGNoVmFsdWUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXQgPSB7IGN1cnI6IGN1cnJlbnRWYWx1ZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50UHJvbWlzZSkge1xuICAgICAgaW5pdC5uZXh0ID0gY3VycmVudFByb21pc2U7XG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWxDaHVuaykge1xuICAgICAgaW5pdC50eXBlID0gU1RSRUFNQUJMRV9WQUxVRV9UWVBFO1xuICAgIH1cblxuICAgIHJldHVybiBpbml0O1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBgY3VycmVudFZhbHVlYCBhbmQgYGN1cnJlbnRQYXRjaFZhbHVlYCBpZiBuZWVkZWQuXG4gIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlU3RhdGVzKHZhbHVlOiBUKSB7XG4gICAgLy8gSWYgd2UgY2FuIG9ubHkgc2VuZCBhIHBhdGNoIG92ZXIgdGhlIHdpcmUsIGl0J3MgYmV0dGVyIHRvIGRvIHNvLlxuICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoY3VycmVudFZhbHVlKSkge1xuICAgICAgICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gWzAsIHZhbHVlLnNsaWNlKGN1cnJlbnRWYWx1ZS5sZW5ndGgpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtYWJsZTogU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPiA9IHtcbiAgICBzZXQgW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10oc3RhdGU6IGJvb2xlYW4pIHtcbiAgICAgIGxvY2tlZCA9IHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZWQodHJ1ZSk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWU6IFQpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLnVwZGF0ZSgpJyk7XG5cbiAgICAgIGNvbnN0IHJlc29sdmVQcmV2aW91cyA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuXG4gICAgICB1cGRhdGVWYWx1ZVN0YXRlcyh2YWx1ZSk7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlc29sdmFibGUucHJvbWlzZTtcbiAgICAgIHJlc29sdmVQcmV2aW91cyhjcmVhdGVXcmFwcGVkKCkpO1xuXG4gICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBhcHBlbmQodmFsdWU6IFQpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmFwcGVuZCgpJyk7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICFpc1ZhbGlkRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAuYXBwZW5kKCk6IFRoZSB2YWx1ZSB0eXBlIGNhbid0IGJlIGFwcGVuZGVkIHRvIHRoZSBzdHJlYW0uIFJlY2VpdmVkOiAke3R5cGVvZiB2YWx1ZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gWzAsIHZhbHVlXTtcbiAgICAgICAgICAoY3VycmVudFZhbHVlIGFzIHN0cmluZykgPSBjdXJyZW50VmFsdWUgKyB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IFsxLCB2YWx1ZV07XG4gICAgICAgICAgKGN1cnJlbnRWYWx1ZSBhcyB1bmtub3duIGFzIFJlYWN0RWxlbWVudCkgPSAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICB7Y3VycmVudFZhbHVlfVxuICAgICAgICAgICAgICB7dmFsdWV9XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSBbMSwgdmFsdWVdO1xuICAgICAgICAoY3VycmVudFZhbHVlIGFzIFJlYWN0RWxlbWVudCkgPSAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIHtjdXJyZW50VmFsdWV9XG4gICAgICAgICAgICB7dmFsdWV9XG4gICAgICAgICAgPC8+XG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYC5hcHBlbmQoKTogVGhlIGN1cnJlbnQgdmFsdWUgZG9lc24ndCBzdXBwb3J0IGFwcGVuZGluZyBkYXRhLiBUeXBlOiAke3R5cGVvZiBjdXJyZW50VmFsdWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzb2x2ZVByZXZpb3VzID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgICAgcmVzb2x2ZVByZXZpb3VzKGNyZWF0ZVdyYXBwZWQoKSk7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGVycm9yKGVycm9yOiBhbnkpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmVycm9yKCknKTtcblxuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgY3VycmVudEVycm9yID0gZXJyb3I7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHVuZGVmaW5lZDtcblxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHsgZXJyb3IgfSk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgZG9uZSguLi5hcmdzOiBbXSB8IFtUXSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZG9uZSgpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdXBkYXRlVmFsdWVTdGF0ZXMoYXJnc1swXSk7XG4gICAgICAgIHJlc29sdmFibGUucmVzb2x2ZShjcmVhdGVXcmFwcGVkKCkpO1xuICAgICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHt9KTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gc3RyZWFtYWJsZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyZWFtYWJsZVVJLCBjcmVhdGVTdHJlYW1hYmxlVmFsdWUgfTtcblxudHlwZSBTdHJlYW1hYmxlID0gUmVhY3ROb2RlIHwgUHJvbWlzZTxSZWFjdE5vZGU+O1xudHlwZSBSZW5kZXJlcjxUPiA9IChcbiAgcHJvcHM6IFQsXG4pID0+XG4gIHwgU3RyZWFtYWJsZVxuICB8IEdlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPlxuICB8IEFzeW5jR2VuZXJhdG9yPFN0cmVhbWFibGUsIFN0cmVhbWFibGUsIHZvaWQ+O1xuXG4vKipcbiAqIGByZW5kZXJgIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHN0cmVhbWFibGUgVUkgZnJvbSBzb21lIExMTXMuXG4gKiBUaGlzIEFQSSBvbmx5IHN1cHBvcnRzIE9wZW5BSSdzIEdQVCBtb2RlbHMgd2l0aCBGdW5jdGlvbiBDYWxsaW5nIGFuZCBBc3Npc3RhbnRzIFRvb2xzLFxuICogcGxlYXNlIHVzZSBgc3RyZWFtVUlgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggb3RoZXIgcHJvdmlkZXJzLlxuICpcbiAqIEBkZXByZWNhdGVkIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBgc3RyZWFtVUlgIEFQSSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFJIFNESyBDb3JlIEFQSXNcbiAqIGFuZCBmdXR1cmUgZmVhdHVyZXMuIFRoaXMgQVBJIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyPFxuICBUUyBleHRlbmRzIHtcbiAgICBbbmFtZTogc3RyaW5nXTogei5TY2hlbWE7XG4gIH0gPSB7fSxcbiAgRlMgZXh0ZW5kcyB7XG4gICAgW25hbWU6IHN0cmluZ106IHouU2NoZW1hO1xuICB9ID0ge30sXG4+KG9wdGlvbnM6IHtcbiAgLyoqXG4gICAqIFRoZSBtb2RlbCBuYW1lIHRvIHVzZS4gTXVzdCBiZSBPcGVuQUkgU0RLIGNvbXBhdGlibGUuIFRvb2xzIGFuZCBGdW5jdGlvbnMgYXJlIG9ubHkgc3VwcG9ydGVkXG4gICAqIEdQVCBtb2RlbHMgKDMuNS80KSwgT3BlbkFJIEFzc2lzdGFudHMsIE1pc3RyYWwgc21hbGwgYW5kIGxhcmdlLCBhbmQgRmlyZXdvcmtzIGZpcmVmdW5jdGlvbi12MS5cbiAgICpcbiAgICogQGV4YW1wbGUgXCJncHQtMy41LXR1cmJvXCJcbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcHJvdmlkZXIgaW5zdGFuY2UgdG8gdXNlLiBDdXJyZW50bHkgdGhlIG9ubHkgcHJvdmlkZXIgYXZhaWxhYmxlIGlzIE9wZW5BSS5cbiAgICogVGhpcyBuZWVkcyB0byBtYXRjaCB0aGUgbW9kZWwgbmFtZS5cbiAgICovXG4gIHByb3ZpZGVyOiBPcGVuQUk7XG4gIG1lc3NhZ2VzOiBQYXJhbWV0ZXJzPFxuICAgIHR5cGVvZiBPcGVuQUkucHJvdG90eXBlLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlXG4gID5bMF1bJ21lc3NhZ2VzJ107XG4gIHRleHQ/OiBSZW5kZXJlcjx7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bGwgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNvIGZhci5cbiAgICAgKi9cbiAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIG5ldyBhcHBlbmRlZCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc2luY2UgdGhlIGxhc3QgYHRleHRgIGNhbGwuXG4gICAgICovXG4gICAgZGVsdGE6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBtb2RlbCBpcyBkb25lIGdlbmVyYXRpbmcgdGV4dC5cbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBgY29udGVudGAgd2lsbCBiZSB0aGUgZmluYWwgb3V0cHV0IGFuZCB0aGlzIGNhbGwgd2lsbCBiZSB0aGUgbGFzdC5cbiAgICAgKi9cbiAgICBkb25lOiBib29sZWFuO1xuICB9PjtcbiAgdG9vbHM/OiB7XG4gICAgW25hbWUgaW4ga2V5b2YgVFNdOiB7XG4gICAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICAgIHBhcmFtZXRlcnM6IFRTW25hbWVdO1xuICAgICAgcmVuZGVyOiBSZW5kZXJlcjx6LmluZmVyPFRTW25hbWVdPj47XG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb25zPzoge1xuICAgIFtuYW1lIGluIGtleW9mIEZTXToge1xuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gICAgICBwYXJhbWV0ZXJzOiBGU1tuYW1lXTtcbiAgICAgIHJlbmRlcjogUmVuZGVyZXI8ei5pbmZlcjxGU1tuYW1lXT4+O1xuICAgIH07XG4gIH07XG4gIGluaXRpYWw/OiBSZWFjdE5vZGU7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xufSk6IFJlYWN0Tm9kZSB7XG4gIGNvbnN0IHVpID0gY3JlYXRlU3RyZWFtYWJsZVVJKG9wdGlvbnMuaW5pdGlhbCk7XG5cbiAgLy8gVGhlIGRlZmF1bHQgdGV4dCByZW5kZXJlciBqdXN0IHJldHVybnMgdGhlIGNvbnRlbnQgYXMgc3RyaW5nLlxuICBjb25zdCB0ZXh0ID0gb3B0aW9ucy50ZXh0XG4gICAgPyBvcHRpb25zLnRleHRcbiAgICA6ICh7IGNvbnRlbnQgfTogeyBjb250ZW50OiBzdHJpbmcgfSkgPT4gY29udGVudDtcblxuICBjb25zdCBmdW5jdGlvbnMgPSBvcHRpb25zLmZ1bmN0aW9uc1xuICAgID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy5mdW5jdGlvbnMpLm1hcChcbiAgICAgICAgKFtuYW1lLCB7IGRlc2NyaXB0aW9uLCBwYXJhbWV0ZXJzIH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHpvZFRvSnNvblNjaGVtYShwYXJhbWV0ZXJzKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHRvb2xzID0gb3B0aW9ucy50b29sc1xuICAgID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy50b29scykubWFwKFxuICAgICAgICAoW25hbWUsIHsgZGVzY3JpcHRpb24sIHBhcmFtZXRlcnMgfV0pID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyBhcyBjb25zdCxcbiAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB6b2RUb0pzb25TY2hlbWEocGFyYW1ldGVycykgYXMgUmVjb3JkPFxuICAgICAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgICAgICB1bmtub3duXG4gICAgICAgICAgICAgID4sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICApXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGZ1bmN0aW9ucyAmJiB0b29scykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbid0IGhhdmUgYm90aCBmdW5jdGlvbnMgYW5kIHRvb2xzIGRlZmluZWQuIFBsZWFzZSBjaG9vc2Ugb25lIG9yIHRoZSBvdGhlci5cIixcbiAgICApO1xuICB9XG5cbiAgbGV0IGZpbmlzaGVkOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlbmRlcihcbiAgICBhcmdzOiBhbnksXG4gICAgcmVuZGVyZXI6IHVuZGVmaW5lZCB8IFJlbmRlcmVyPGFueT4sXG4gICAgcmVzOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVTdHJlYW1hYmxlVUk+LFxuICApIHtcbiAgICBpZiAoIXJlbmRlcmVyKSByZXR1cm47XG5cbiAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8dm9pZD4oKTtcblxuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgZmluaXNoZWQgPSBmaW5pc2hlZC50aGVuKCgpID0+IHJlc29sdmFibGUucHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaGVkID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gcmVuZGVyZXIoYXJncyk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlIHx8XG4gICAgICAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndGhlbicgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgKSB7XG4gICAgICBjb25zdCBub2RlID0gYXdhaXQgKHZhbHVlIGFzIFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPik7XG4gICAgICByZXMudXBkYXRlKG5vZGUpO1xuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHZhbHVlICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiB2YWx1ZVxuICAgICkge1xuICAgICAgY29uc3QgaXQgPSB2YWx1ZSBhcyBBc3luY0dlbmVyYXRvcjxcbiAgICAgICAgUmVhY3QuUmVhY3ROb2RlLFxuICAgICAgICBSZWFjdC5SZWFjdE5vZGUsXG4gICAgICAgIHZvaWRcbiAgICAgID47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlIGFzIEdlbmVyYXRvcjxSZWFjdC5SZWFjdE5vZGUsIFJlYWN0LlJlYWN0Tm9kZSwgdm9pZD47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9XG4gIH1cblxuICAoYXN5bmMgKCkgPT4ge1xuICAgIGxldCBoYXNGdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBjb250ZW50ID0gJyc7XG5cbiAgICBjb25zdW1lU3RyZWFtKFxuICAgICAgT3BlbkFJU3RyZWFtKFxuICAgICAgICAoYXdhaXQgb3B0aW9ucy5wcm92aWRlci5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICAgICAgbW9kZWw6IG9wdGlvbnMubW9kZWwsXG4gICAgICAgICAgbWVzc2FnZXM6IG9wdGlvbnMubWVzc2FnZXMsXG4gICAgICAgICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMudGVtcGVyYXR1cmUsXG4gICAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAgIC4uLihmdW5jdGlvbnNcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgLi4uKHRvb2xzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pKSBhcyBhbnksXG4gICAgICAgIHtcbiAgICAgICAgICAuLi4oZnVuY3Rpb25zXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBhc3luYyBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoZnVuY3Rpb25DYWxsUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgaGFzRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaGFuZGxlUmVuZGVyKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxQYXlsb2FkLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5mdW5jdGlvbnM/LltmdW5jdGlvbkNhbGxQYXlsb2FkLm5hbWUgYXMgYW55XVxuICAgICAgICAgICAgICAgICAgICAgID8ucmVuZGVyLFxuICAgICAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgLi4uKHRvb2xzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBhc3luYyBleHBlcmltZW50YWxfb25Ub29sQ2FsbCh0b29sQ2FsbFBheWxvYWQ6IGFueSkge1xuICAgICAgICAgICAgICAgICAgaGFzRnVuY3Rpb24gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBtaWdodCBuZWVkIFByb21pc2UuYWxsIGhlcmU/XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbENhbGxQYXlsb2FkLnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgICAgICAgICB0b29sLmZ1bmMuYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudG9vbHM/Llt0b29sLmZ1bmMubmFtZSBhcyBhbnldPy5yZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgdWksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgb25UZXh0KGNodW5rKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IGNodW5rO1xuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKHsgY29udGVudCwgZG9uZTogZmFsc2UsIGRlbHRhOiBjaHVuayB9LCB0ZXh0LCB1aSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBvbkZpbmFsKCkge1xuICAgICAgICAgICAgaWYgKGhhc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgICB1aS5kb25lKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKHsgY29udGVudCwgZG9uZTogdHJ1ZSB9LCB0ZXh0LCB1aSk7XG4gICAgICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgICAgIHVpLmRvbmUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgKSxcbiAgICApO1xuICB9KSgpO1xuXG4gIHJldHVybiB1aS52YWx1ZTtcbn1cbiIsImltcG9ydCB7IEFQSUNhbGxFcnJvciwgUmV0cnlFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlLCBpc0Fib3J0RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAnLi9kZWxheSc7XG5cbmV4cG9ydCB0eXBlIFJldHJ5RnVuY3Rpb24gPSA8T1VUUFVUPihcbiAgZm46ICgpID0+IFByb21pc2VMaWtlPE9VVFBVVD4sXG4pID0+IFByb21pc2VMaWtlPE9VVFBVVD47XG5cbi8qKlxuVGhlIGByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmZgIHN0cmF0ZWd5IHJldHJpZXMgYSBmYWlsZWQgQVBJIGNhbGwgd2l0aCBhbiBleHBvbmVudGlhbCBiYWNrb2ZmLlxuWW91IGNhbiBjb25maWd1cmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMsIHRoZSBpbml0aWFsIGRlbGF5LCBhbmQgdGhlIGJhY2tvZmYgZmFjdG9yLlxuICovXG5leHBvcnQgY29uc3QgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmID1cbiAgKHtcbiAgICBtYXhSZXRyaWVzID0gMixcbiAgICBpbml0aWFsRGVsYXlJbk1zID0gMjAwMCxcbiAgICBiYWNrb2ZmRmFjdG9yID0gMixcbiAgfSA9IHt9KTogUmV0cnlGdW5jdGlvbiA9PlxuICBhc3luYyA8T1VUUFVUPihmOiAoKSA9PiBQcm9taXNlTGlrZTxPVVRQVVQ+KSA9PlxuICAgIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICAgICAgbWF4UmV0cmllcyxcbiAgICAgIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgICAgIGJhY2tvZmZGYWN0b3IsXG4gICAgfSk7XG5cbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmY8T1VUUFVUPihcbiAgZjogKCkgPT4gUHJvbWlzZUxpa2U8T1VUUFVUPixcbiAge1xuICAgIG1heFJldHJpZXMsXG4gICAgZGVsYXlJbk1zLFxuICAgIGJhY2tvZmZGYWN0b3IsXG4gIH06IHsgbWF4UmV0cmllczogbnVtYmVyOyBkZWxheUluTXM6IG51bWJlcjsgYmFja29mZkZhY3RvcjogbnVtYmVyIH0sXG4gIGVycm9yczogdW5rbm93bltdID0gW10sXG4pOiBQcm9taXNlPE9VVFBVVD4ge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCByZXRyeSB3aGVuIHRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkXG4gICAgfVxuXG4gICAgaWYgKG1heFJldHJpZXMgPT09IDApIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCB3cmFwIHRoZSBlcnJvciB3aGVuIHJldHJpZXMgYXJlIGRpc2FibGVkXG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcblxuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246ICdtYXhSZXRyaWVzRXhjZWVkZWQnLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9ycyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikgJiZcbiAgICAgIGVycm9yLmlzUmV0cnlhYmxlID09PSB0cnVlICYmXG4gICAgICB0cnlOdW1iZXIgPD0gbWF4UmV0cmllc1xuICAgICkge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCB3cmFwIHRoZSBlcnJvciB3aGVuIGEgbm9uLXJldHJ5YWJsZSBlcnJvciBvY2N1cnMgb24gdGhlIGZpcnN0IHRyeVxuICAgIH1cblxuICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzIHdpdGggbm9uLXJldHJ5YWJsZSBlcnJvcjogJyR7ZXJyb3JNZXNzYWdlfSdgLFxuICAgICAgcmVhc29uOiAnZXJyb3JOb3RSZXRyeWFibGUnLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cbiIsImV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxheShkZWxheUluTXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5SW5NcykpO1xufVxuIiwiY29uc3QgbWltZVR5cGVTaWduYXR1cmVzID0gW1xuICB7IG1pbWVUeXBlOiAnaW1hZ2UvZ2lmJyBhcyBjb25zdCwgYnl0ZXM6IFsweDQ3LCAweDQ5LCAweDQ2XSB9LFxuICB7IG1pbWVUeXBlOiAnaW1hZ2UvcG5nJyBhcyBjb25zdCwgYnl0ZXM6IFsweDg5LCAweDUwLCAweDRlLCAweDQ3XSB9LFxuICB7IG1pbWVUeXBlOiAnaW1hZ2UvanBlZycgYXMgY29uc3QsIGJ5dGVzOiBbMHhmZiwgMHhkOF0gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL3dlYnAnIGFzIGNvbnN0LCBieXRlczogWzB4NTIsIDB4NDksIDB4NDYsIDB4NDZdIH0sXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0SW1hZ2VNaW1lVHlwZShcbiAgaW1hZ2U6IFVpbnQ4QXJyYXksXG4pOiAnaW1hZ2UvanBlZycgfCAnaW1hZ2UvcG5nJyB8ICdpbWFnZS9naWYnIHwgJ2ltYWdlL3dlYnAnIHwgdW5kZWZpbmVkIHtcbiAgZm9yIChjb25zdCB7IGJ5dGVzLCBtaW1lVHlwZSB9IG9mIG1pbWVUeXBlU2lnbmF0dXJlcykge1xuICAgIGlmIChcbiAgICAgIGltYWdlLmxlbmd0aCA+PSBieXRlcy5sZW5ndGggJiZcbiAgICAgIGJ5dGVzLmV2ZXJ5KChieXRlLCBpbmRleCkgPT4gaW1hZ2VbaW5kZXhdID09PSBieXRlKVxuICAgICkge1xuICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgeyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbn0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5cbi8qKlxuRGF0YSBjb250ZW50LiBDYW4gZWl0aGVyIGJlIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLCBhIFVpbnQ4QXJyYXksIGFuIEFycmF5QnVmZmVyLCBvciBhIEJ1ZmZlci5cbiAqL1xuZXhwb3J0IHR5cGUgRGF0YUNvbnRlbnQgPSBzdHJpbmcgfCBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIgfCBCdWZmZXI7XG5cbi8qKlxuQ29udmVydHMgZGF0YSBjb250ZW50IHRvIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuXG5AcGFyYW0gY29udGVudCAtIERhdGEgY29udGVudCB0byBjb252ZXJ0LlxuQHJldHVybnMgQmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50OiBEYXRhQ29udGVudCk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cblxuICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChjb250ZW50KTtcbn1cblxuLyoqXG5Db252ZXJ0cyBkYXRhIGNvbnRlbnQgdG8gYSBVaW50OEFycmF5LlxuXG5AcGFyYW0gY29udGVudCAtIERhdGEgY29udGVudCB0byBjb252ZXJ0LlxuQHJldHVybnMgVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShcbiAgY29udGVudDogRGF0YUNvbnRlbnQsXG4pOiBVaW50OEFycmF5IHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICdJbnZhbGlkIGRhdGEgY29udGVudC4gQ29udGVudCBzdHJpbmcgaXMgbm90IGEgYmFzZTY0LWVuY29kZWQgaW1hZ2UuJyxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuXG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG4iLCJleHBvcnQgY2xhc3MgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHJlYWRvbmx5IHJvbGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgcm9sZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgbWVzc2FnZSByb2xlOiAnJHtyb2xlfScuIE11c3QgYmUgb25lIG9mOiBcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCIuYCxcbiAgfToge1xuICAgIHJvbGU6IHN0cmluZztcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG5cbiAgICB0aGlzLm5hbWUgPSAnQUlfSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3InO1xuXG4gICAgdGhpcy5yb2xlID0gcm9sZTtcbiAgfVxuXG4gIHN0YXRpYyBpc0ludmFsaWRNZXNzYWdlUm9sZUVycm9yKFxuICAgIGVycm9yOiB1bmtub3duLFxuICApOiBlcnJvciBpcyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIGVycm9yLm5hbWUgPT09ICdBSV9JbnZhbGlkTWVzc2FnZVJvbGVFcnJvcicgJiZcbiAgICAgIHR5cGVvZiAoZXJyb3IgYXMgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IpLnJvbGUgPT09ICdzdHJpbmcnXG4gICAgKTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG5cbiAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBMYW5ndWFnZU1vZGVsVjFJbWFnZVBhcnQsXG4gIExhbmd1YWdlTW9kZWxWMU1lc3NhZ2UsXG4gIExhbmd1YWdlTW9kZWxWMVByb21wdCxcbiAgTGFuZ3VhZ2VNb2RlbFYxVGV4dFBhcnQsXG59IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgQ29yZU1lc3NhZ2UgfSBmcm9tICcuLi9wcm9tcHQvbWVzc2FnZSc7XG5pbXBvcnQgeyBkZXRlY3RJbWFnZU1pbWVUeXBlIH0gZnJvbSAnLi4vdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUnO1xuaW1wb3J0IHsgY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5IH0gZnJvbSAnLi9kYXRhLWNvbnRlbnQnO1xuaW1wb3J0IHsgVmFsaWRhdGVkUHJvbXB0IH0gZnJvbSAnLi9nZXQtdmFsaWRhdGVkLXByb21wdCc7XG5pbXBvcnQgeyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciB9IGZyb20gJy4vaW52YWxpZC1tZXNzYWdlLXJvbGUtZXJyb3InO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KFxuICBwcm9tcHQ6IFZhbGlkYXRlZFByb21wdCxcbik6IExhbmd1YWdlTW9kZWxWMVByb21wdCB7XG4gIGNvbnN0IGxhbmd1YWdlTW9kZWxNZXNzYWdlczogTGFuZ3VhZ2VNb2RlbFYxUHJvbXB0ID0gW107XG5cbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCkge1xuICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHsgcm9sZTogJ3N5c3RlbScsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfSk7XG4gIH1cblxuICBjb25zdCBwcm9tcHRUeXBlID0gcHJvbXB0LnR5cGU7XG4gIHN3aXRjaCAocHJvbXB0VHlwZSkge1xuICAgIGNhc2UgJ3Byb21wdCc6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBjb250ZW50OiBbeyB0eXBlOiAndGV4dCcsIHRleHQ6IHByb21wdC5wcm9tcHQgfV0sXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ21lc3NhZ2VzJzoge1xuICAgICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goXG4gICAgICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAoY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UpLFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2s6IG5ldmVyID0gcHJvbXB0VHlwZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcHJvbXB0IHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UoXG4gIG1lc3NhZ2U6IENvcmVNZXNzYWdlLFxuKTogTGFuZ3VhZ2VNb2RlbFYxTWVzc2FnZSB7XG4gIGNvbnN0IHJvbGUgPSBtZXNzYWdlLnJvbGU7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgJ3N5c3RlbSc6IHtcbiAgICAgIHJldHVybiB7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgfTtcbiAgICB9XG5cbiAgICBjYXNlICd1c2VyJzoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6ICd0ZXh0JywgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoXG4gICAgICAgICAgKHBhcnQpOiBMYW5ndWFnZU1vZGVsVjFUZXh0UGFydCB8IExhbmd1YWdlTW9kZWxWMUltYWdlUGFydCA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSAnaW1hZ2UnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQuaW1hZ2UgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiBwYXJ0LmltYWdlLFxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgc3RyaW5nIGltYWdlIHBhcnRzIHRvIHVybHNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQuaW1hZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhcnQuaW1hZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaHR0cDonOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2h0dHBzOic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGF0YTonOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IHBhcnQuaW1hZ2Uuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoJzsnKVswXS5zcGxpdCgnOicpWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShiYXNlNjRDb250ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgRXJyb3IgcHJvY2Vzc2luZyBkYXRhIFVSTDogJHtnZXRFcnJvck1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBgVW5zdXBwb3J0ZWQgVVJMIHByb3RvY29sOiAke3VybC5wcm90b2NvbH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF9pZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBhIFVSTFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlVWludDggPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkocGFydC5pbWFnZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZVVpbnQ4LFxuICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGUgPz8gZGV0ZWN0SW1hZ2VNaW1lVHlwZShpbWFnZVVpbnQ4KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2FzZSAnYXNzaXN0YW50Jzoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogJ3RleHQnLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSB0ZXh0IHBhcnRzOlxuICAgICAgICAgIHBhcnQgPT4gcGFydC50eXBlICE9PSAndGV4dCcgfHwgcGFydC50ZXh0ICE9PSAnJyxcbiAgICAgICAgKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2FzZSAndG9vbCc6IHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2s6IG5ldmVyID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBJbnZhbGlkUHJvbXB0RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IENvcmVNZXNzYWdlIH0gZnJvbSAnLi9tZXNzYWdlJztcbmltcG9ydCB7IFByb21wdCB9IGZyb20gJy4vcHJvbXB0JztcblxuZXhwb3J0IHR5cGUgVmFsaWRhdGVkUHJvbXB0ID1cbiAgfCB7XG4gICAgICB0eXBlOiAncHJvbXB0JztcbiAgICAgIHByb21wdDogc3RyaW5nO1xuICAgICAgbWVzc2FnZXM6IHVuZGVmaW5lZDtcbiAgICAgIHN5c3RlbT86IHN0cmluZztcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogJ21lc3NhZ2VzJztcbiAgICAgIHByb21wdDogdW5kZWZpbmVkO1xuICAgICAgbWVzc2FnZXM6IENvcmVNZXNzYWdlW107XG4gICAgICBzeXN0ZW0/OiBzdHJpbmc7XG4gICAgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbGlkYXRlZFByb21wdChwcm9tcHQ6IFByb21wdCk6IFZhbGlkYXRlZFByb21wdCB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6ICdwcm9tcHQgb3IgbWVzc2FnZXMgbXVzdCBiZSBkZWZpbmVkJyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6ICdwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWUnLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHByb21wdC5wcm9tcHQgIT0gbnVsbFxuICAgID8ge1xuICAgICAgICB0eXBlOiAncHJvbXB0JyxcbiAgICAgICAgcHJvbXB0OiBwcm9tcHQucHJvbXB0LFxuICAgICAgICBtZXNzYWdlczogdW5kZWZpbmVkLFxuICAgICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW0sXG4gICAgICB9XG4gICAgOiB7XG4gICAgICAgIHR5cGU6ICdtZXNzYWdlcycsXG4gICAgICAgIHByb21wdDogdW5kZWZpbmVkLFxuICAgICAgICBtZXNzYWdlczogcHJvbXB0Lm1lc3NhZ2VzISwgLy8gb25seSBwb3NzaWJsZSBjYXNlIGJjIG9mIGNoZWNrcyBhYm92ZVxuICAgICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW0sXG4gICAgICB9O1xufVxuIiwiaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IENhbGxTZXR0aW5ncyB9IGZyb20gJy4vY2FsbC1zZXR0aW5ncyc7XG5cbi8qKlxuICogVmFsaWRhdGVzIGNhbGwgc2V0dGluZ3MgYW5kIHNldHMgZGVmYXVsdCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzZWVkLFxuICBtYXhSZXRyaWVzLFxufTogQ2FsbFNldHRpbmdzKTogQ2FsbFNldHRpbmdzIHtcbiAgaWYgKG1heFRva2VucyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFRva2VucycsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6ICdtYXhUb2tlbnMgbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXhUb2tlbnMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhUb2tlbnMnLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiAnbWF4VG9rZW5zIG11c3QgYmUgPj0gMScsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICd0ZW1wZXJhdHVyZScsXG4gICAgICAgIHZhbHVlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgbWVzc2FnZTogJ3RlbXBlcmF0dXJlIG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ3RvcFAnLFxuICAgICAgICB2YWx1ZTogdG9wUCxcbiAgICAgICAgbWVzc2FnZTogJ3RvcFAgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByZXNlbmNlUGVuYWx0eSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6ICdwcmVzZW5jZVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBmcmVxdWVuY3lQZW5hbHR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiAnZnJlcXVlbmN5UGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZWVkICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc2VlZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ3NlZWQnLFxuICAgICAgICB2YWx1ZTogc2VlZCxcbiAgICAgICAgbWVzc2FnZTogJ3NlZWQgbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFJldHJpZXMnLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogJ21heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnbWF4UmV0cmllcycsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiAnbWF4UmV0cmllcyBtdXN0IGJlID49IDAnLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXhUb2tlbnMsXG4gICAgdGVtcGVyYXR1cmU6IHRlbXBlcmF0dXJlID8/IDAsXG4gICAgdG9wUCxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzZWVkLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXMgPz8gMixcbiAgfTtcbn1cbiIsImltcG9ydCB7IEpTT05TY2hlbWE3IH0gZnJvbSAnanNvbi1zY2hlbWEnO1xuaW1wb3J0ICogYXMgeiBmcm9tICd6b2QnO1xuaW1wb3J0IHpvZFRvSnNvblNjaGVtYSBmcm9tICd6b2QtdG8tanNvbi1zY2hlbWEnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFpvZFRvSlNPTlNjaGVtYShcbiAgem9kU2NoZW1hOiB6LlNjaGVtYTx1bmtub3duPixcbik6IEpTT05TY2hlbWE3IHtcbiAgLy8gd2UgYXNzdW1lIHRoYXQgem9kVG9Kc29uU2NoZW1hIHdpbGwgcmV0dXJuIGEgdmFsaWQgSlNPTlNjaGVtYTdcbiAgcmV0dXJuIHpvZFRvSnNvblNjaGVtYSh6b2RTY2hlbWEpIGFzIEpTT05TY2hlbWE3O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzTm9uRW1wdHlPYmplY3QoXG4gIG9iamVjdDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCB1bmRlZmluZWQgfCBudWxsLFxuKTogb2JqZWN0IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID4gMDtcbn1cbiIsImltcG9ydCB7XG4gIExhbmd1YWdlTW9kZWxWMUZ1bmN0aW9uVG9vbCxcbiAgTGFuZ3VhZ2VNb2RlbFYxVG9vbENob2ljZSxcbn0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyBDb3JlVG9vbCB9IGZyb20gJy4uL3Rvb2wvdG9vbCc7XG5pbXBvcnQgeyBDb3JlVG9vbENob2ljZSB9IGZyb20gJy4uL3R5cGVzL2xhbmd1YWdlLW1vZGVsJztcbmltcG9ydCB7IGNvbnZlcnRab2RUb0pTT05TY2hlbWEgfSBmcm9tICcuLi91dGlsL2NvbnZlcnQtem9kLXRvLWpzb24tc2NoZW1hJztcbmltcG9ydCB7IGlzTm9uRW1wdHlPYmplY3QgfSBmcm9tICcuLi91dGlsL2lzLW5vbi1lbXB0eS1vYmplY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZTxcbiAgVE9PTFMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBDb3JlVG9vbD4sXG4+KHtcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG59OiB7XG4gIHRvb2xzOiBUT09MUyB8IHVuZGVmaW5lZDtcbiAgdG9vbENob2ljZTogQ29yZVRvb2xDaG9pY2U8VE9PTFM+IHwgdW5kZWZpbmVkO1xufSk6IHtcbiAgdG9vbHM6IExhbmd1YWdlTW9kZWxWMUZ1bmN0aW9uVG9vbFtdIHwgdW5kZWZpbmVkO1xuICB0b29sQ2hvaWNlOiBMYW5ndWFnZU1vZGVsVjFUb29sQ2hvaWNlIHwgdW5kZWZpbmVkO1xufSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHVuZGVmaW5lZCxcbiAgICAgIHRvb2xDaG9pY2U6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b29sczogT2JqZWN0LmVudHJpZXModG9vbHMpLm1hcCgoW25hbWUsIHRvb2xdKSA9PiAoe1xuICAgICAgdHlwZTogJ2Z1bmN0aW9uJyBhcyBjb25zdCxcbiAgICAgIG5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgIHBhcmFtZXRlcnM6IGNvbnZlcnRab2RUb0pTT05TY2hlbWEodG9vbC5wYXJhbWV0ZXJzKSxcbiAgICB9KSksXG4gICAgdG9vbENob2ljZTpcbiAgICAgIHRvb2xDaG9pY2UgPT0gbnVsbFxuICAgICAgICA/IHsgdHlwZTogJ2F1dG8nIH1cbiAgICAgICAgOiB0eXBlb2YgdG9vbENob2ljZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB7IHR5cGU6IHRvb2xDaG9pY2UgfVxuICAgICAgICA6IHsgdHlwZTogJ3Rvb2wnIGFzIGNvbnN0LCB0b29sTmFtZTogdG9vbENob2ljZS50b29sTmFtZSBhcyBzdHJpbmcgfSxcbiAgfTtcbn1cbiIsImltcG9ydCB7XG4gIGNyZWF0ZVBhcnNlcixcbiAgdHlwZSBFdmVudFNvdXJjZVBhcnNlcixcbiAgdHlwZSBQYXJzZWRFdmVudCxcbiAgdHlwZSBSZWNvbm5lY3RJbnRlcnZhbCxcbn0gZnJvbSAnZXZlbnRzb3VyY2UtcGFyc2VyJztcbmltcG9ydCB7IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyB9IGZyb20gJy4vb3BlbmFpLXN0cmVhbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25DYWxsUGF5bG9hZCB7XG4gIG5hbWU6IHN0cmluZztcbiAgYXJndW1lbnRzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbENhbGxQYXlsb2FkIHtcbiAgdG9vbHM6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHR5cGU6ICdmdW5jdGlvbic7XG4gICAgZnVuYzoge1xuICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgYXJndW1lbnRzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICB9O1xuICB9W107XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGFuZCBoZWxwZXIgY2FsbGJhY2sgbWV0aG9kcyBmb3IgQUlTdHJlYW0gc3RyZWFtIGxpZmVjeWNsZSBldmVudHMuXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zIHtcbiAgLyoqIGBvblN0YXJ0YDogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGluaXRpYWxpemVkLiAqL1xuICBvblN0YXJ0PzogKCkgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKiBgb25Db21wbGV0aW9uYDogQ2FsbGVkIGZvciBlYWNoIHRva2VuaXplZCBtZXNzYWdlLiAqL1xuICBvbkNvbXBsZXRpb24/OiAoY29tcGxldGlvbjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqIGBvbkZpbmFsYDogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGNsb3NlZCB3aXRoIHRoZSBmaW5hbCBjb21wbGV0aW9uIG1lc3NhZ2UuICovXG4gIG9uRmluYWw/OiAoY29tcGxldGlvbjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqIGBvblRva2VuYDogQ2FsbGVkIGZvciBlYWNoIHRva2VuaXplZCBtZXNzYWdlLiAqL1xuICBvblRva2VuPzogKHRva2VuOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKiogYG9uVGV4dGA6IENhbGxlZCBmb3IgZWFjaCB0ZXh0IGNodW5rLiAqL1xuICBvblRleHQ/OiAodGV4dDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgZmxhZyBpcyBubyBsb25nZXIgdXNlZCBhbmQgb25seSByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAqIFlvdSBjYW4gcmVtb3ZlIGl0IGZyb20geW91ciBjb2RlLlxuICAgKi9cbiAgZXhwZXJpbWVudGFsX3N0cmVhbURhdGE/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHRoZSBBSVN0cmVhbVBhcnNlci5cbiAqIEBpbnRlcmZhY2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudCAtIFRoZSBldmVudCAodHlwZSkgZnJvbSB0aGUgc2VydmVyIHNpZGUgZXZlbnQgc3RyZWFtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFJU3RyZWFtUGFyc2VyT3B0aW9ucyB7XG4gIGV2ZW50Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEN1c3RvbSBwYXJzZXIgZm9yIEFJU3RyZWFtIGRhdGEuXG4gKiBAaW50ZXJmYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIFRoZSBkYXRhIHRvIGJlIHBhcnNlZC5cbiAqIEBwYXJhbSB7QUlTdHJlYW1QYXJzZXJPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBwYXJzZXIuXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdm9pZH0gVGhlIHBhcnNlZCBkYXRhIG9yIHZvaWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQUlTdHJlYW1QYXJzZXIge1xuICAoZGF0YTogc3RyaW5nLCBvcHRpb25zOiBBSVN0cmVhbVBhcnNlck9wdGlvbnMpOlxuICAgIHwgc3RyaW5nXG4gICAgfCB2b2lkXG4gICAgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBUcmFuc2Zvcm1TdHJlYW0gdGhhdCBwYXJzZXMgZXZlbnRzIGZyb20gYW4gRXZlbnRTb3VyY2Ugc3RyZWFtIHVzaW5nIGEgY3VzdG9tIHBhcnNlci5cbiAqIEBwYXJhbSB7QUlTdHJlYW1QYXJzZXJ9IGN1c3RvbVBhcnNlciAtIEZ1bmN0aW9uIHRvIGhhbmRsZSBldmVudCBkYXRhLlxuICogQHJldHVybnMge1RyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBzdHJpbmc+fSBUcmFuc2Zvcm1TdHJlYW0gcGFyc2luZyBldmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKFxuICBjdXN0b21QYXJzZXI/OiBBSVN0cmVhbVBhcnNlcixcbik6IFRyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBzdHJpbmcgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9PiB7XG4gIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGxldCBldmVudFNvdXJjZVBhcnNlcjogRXZlbnRTb3VyY2VQYXJzZXI7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyID0gY3JlYXRlUGFyc2VyKFxuICAgICAgICAoZXZlbnQ6IFBhcnNlZEV2ZW50IHwgUmVjb25uZWN0SW50ZXJ2YWwpID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoJ2RhdGEnIGluIGV2ZW50ICYmXG4gICAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09ICdldmVudCcgJiZcbiAgICAgICAgICAgICAgZXZlbnQuZGF0YSA9PT0gJ1tET05FXScpIHx8XG4gICAgICAgICAgICAvLyBSZXBsaWNhdGUgZG9lc24ndCBzZW5kIFtET05FXSBidXQgZG9lcyBzZW5kIGEgJ2RvbmUnIGV2ZW50XG4gICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vcmVwbGljYXRlLmNvbS9kb2NzL3N0cmVhbWluZ1xuICAgICAgICAgICAgKGV2ZW50IGFzIGFueSkuZXZlbnQgPT09ICdkb25lJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udHJvbGxlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJ2RhdGEnIGluIGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRNZXNzYWdlID0gY3VzdG9tUGFyc2VyXG4gICAgICAgICAgICAgID8gY3VzdG9tUGFyc2VyKGV2ZW50LmRhdGEsIHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudC5ldmVudCxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICA6IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSkgY29udHJvbGxlci5lbnF1ZXVlKHBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybShjaHVuaykge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIuZmVlZCh0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmspKTtcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIHN0cmVhbSB0aGF0IGVuY29kZXMgaW5wdXQgbWVzc2FnZXMgYW5kIGludm9rZXMgb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICogVGhlIHRyYW5zZm9ybSBzdHJlYW0gdXNlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzIHRvIGV4ZWN1dGUgY3VzdG9tIGxvZ2ljIGF0IGRpZmZlcmVudCBzdGFnZXMgb2YgdGhlIHN0cmVhbSdzIGxpZmVjeWNsZS5cbiAqIC0gYG9uU3RhcnRgOiBDYWxsZWQgb25jZSB3aGVuIHRoZSBzdHJlYW0gaXMgaW5pdGlhbGl6ZWQuXG4gKiAtIGBvblRva2VuYDogQ2FsbGVkIGZvciBlYWNoIHRva2VuaXplZCBtZXNzYWdlLlxuICogLSBgb25Db21wbGV0aW9uYDogQ2FsbGVkIGV2ZXJ5IHRpbWUgYW4gQUlTdHJlYW0gY29tcGxldGlvbiBtZXNzYWdlIGlzIHJlY2VpdmVkLiBUaGlzIGNhbiBvY2N1ciBtdWx0aXBsZSB0aW1lcyB3aGVuIHVzaW5nIGUuZy4gT3BlbkFJIGZ1bmN0aW9uc1xuICogLSBgb25GaW5hbGA6IENhbGxlZCBvbmNlIHdoZW4gdGhlIHN0cmVhbSBpcyBjbG9zZWQgd2l0aCB0aGUgZmluYWwgY29tcGxldGlvbiBtZXNzYWdlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gcHJvY2VzcyBhIHN0cmVhbSBvZiBtZXNzYWdlcyBhbmQgcGVyZm9ybSBzcGVjaWZpYyBhY3Rpb25zIGR1cmluZyB0aGUgc3RyZWFtJ3MgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7QUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zfSBbY2FsbGJhY2tzXSAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1TdHJlYW08c3RyaW5nLCBVaW50OEFycmF5Pn0gQSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgZW5jb2RlcyBpbnB1dCBtZXNzYWdlcyBhcyBVaW50OEFycmF5IGFuZCBhbGxvd3MgdGhlIGV4ZWN1dGlvbiBvZiBjdXN0b20gbG9naWMgdGhyb3VnaCBjYWxsYmFja3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGNhbGxiYWNrcyA9IHtcbiAqICAgb25TdGFydDogYXN5bmMgKCkgPT4gY29uc29sZS5sb2coJ1N0cmVhbSBzdGFydGVkJyksXG4gKiAgIG9uVG9rZW46IGFzeW5jICh0b2tlbikgPT4gY29uc29sZS5sb2coYFRva2VuOiAke3Rva2VufWApLFxuICogICBvbkNvbXBsZXRpb246IGFzeW5jIChjb21wbGV0aW9uKSA9PiBjb25zb2xlLmxvZyhgQ29tcGxldGlvbjogJHtjb21wbGV0aW9ufWApXG4gKiAgIG9uRmluYWw6IGFzeW5jICgpID0+IGRhdGEuY2xvc2UoKVxuICogfTtcbiAqIGNvbnN0IHRyYW5zZm9ybWVyID0gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKFxuICBjYjogQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zIHwgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIHwgdW5kZWZpbmVkLFxuKTogVHJhbnNmb3JtU3RyZWFtPHN0cmluZyB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0sIFVpbnQ4QXJyYXk+IHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9ICcnO1xuICBjb25zdCBjYWxsYmFja3MgPSBjYiB8fCB7fTtcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcblxuICAgIGFzeW5jIHRyYW5zZm9ybShtZXNzYWdlLCBjb250cm9sbGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gbWVzc2FnZSA6IG1lc3NhZ2UuY29udGVudDtcblxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShjb250ZW50KSk7XG5cbiAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBjb250ZW50O1xuXG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVG9rZW4pIGF3YWl0IGNhbGxiYWNrcy5vblRva2VuKGNvbnRlbnQpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblRleHQgJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRleHQobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGZsdXNoKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgaXNPcGVuQUlDYWxsYmFja3MgPSBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhjYWxsYmFja3MpO1xuICAgICAgLy8gSWYgaXQncyBPcGVuQUlDYWxsYmFja3MsIGl0IGhhcyBhbiBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgd2hpY2ggbWVhbnMgdGhhdCB0aGUgY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXJcbiAgICAgIC8vIHdpbGwgaGFuZGxlIGNhbGxpbmcgb25Db21wbGV0ZS5cbiAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmICFpc09wZW5BSUNhbGxiYWNrcykge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhcbiAgY2FsbGJhY2tzOiBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMgfCBPcGVuQUlTdHJlYW1DYWxsYmFja3MsXG4pOiBjYWxsYmFja3MgaXMgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIHtcbiAgcmV0dXJuICdleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwnIGluIGNhbGxiYWNrcztcbn1cbi8qKlxuICogUmV0dXJucyBhIHN0YXRlZnVsIGZ1bmN0aW9uIHRoYXQsIHdoZW4gaW52b2tlZCwgdHJpbXMgbGVhZGluZyB3aGl0ZXNwYWNlXG4gKiBmcm9tIHRoZSBpbnB1dCB0ZXh0LiBUaGUgdHJpbW1pbmcgb25seSBvY2N1cnMgb24gdGhlIGZpcnN0IGludm9jYXRpb24sIGVuc3VyaW5nIHRoYXRcbiAqIHN1YnNlcXVlbnQgY2FsbHMgZG8gbm90IGFsdGVyIHRoZSBpbnB1dCB0ZXh0LiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgaW4gc2NlbmFyaW9zXG4gKiB3aGVyZSBhIHRleHQgc3RyZWFtIGlzIGJlaW5nIHByb2Nlc3NlZCBhbmQgb25seSB0aGUgaW5pdGlhbCB3aGl0ZXNwYWNlIHNob3VsZCBiZSByZW1vdmVkLlxuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKHN0cmluZyk6IHN0cmluZ30gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc3RyaW5nIGFzIGlucHV0IGFuZCByZXR1cm5zIGEgc3RyaW5nXG4gKiB3aXRoIGxlYWRpbmcgd2hpdGVzcGFjZSByZW1vdmVkIGlmIGl0IGlzIHRoZSBmaXJzdCBpbnZvY2F0aW9uOyBvdGhlcndpc2UsIGl0IHJldHVybnMgdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgdHJpbVN0YXJ0ID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAqIGNvbnN0IG91dHB1dDEgPSB0cmltU3RhcnQoXCIgICB0ZXh0XCIpOyAvLyBcInRleHRcIlxuICogY29uc3Qgb3V0cHV0MiA9IHRyaW1TdGFydChcIiAgIHRleHRcIik7IC8vIFwiICAgdGV4dFwiXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTogKHRleHQ6IHN0cmluZykgPT4gc3RyaW5nIHtcbiAgbGV0IGlzU3RyZWFtU3RhcnQgPSB0cnVlO1xuXG4gIHJldHVybiAodGV4dDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICBpZiAoaXNTdHJlYW1TdGFydCkge1xuICAgICAgdGV4dCA9IHRleHQudHJpbVN0YXJ0KCk7XG4gICAgICBpZiAodGV4dCkgaXNTdHJlYW1TdGFydCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgUmVhZGFibGVTdHJlYW0gY3JlYXRlZCBmcm9tIHRoZSByZXNwb25zZSwgcGFyc2VkIGFuZCBoYW5kbGVkIHdpdGggY3VzdG9tIGxvZ2ljLlxuICogVGhlIHN0cmVhbSBnb2VzIHRocm91Z2ggdHdvIHRyYW5zZm9ybWF0aW9uIHN0YWdlcywgZmlyc3QgcGFyc2luZyB0aGUgZXZlbnRzIGFuZCB0aGVuXG4gKiBpbnZva2luZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzLlxuICpcbiAqIEZvciAyeHggSFRUUCByZXNwb25zZXM6XG4gKiAtIFRoZSBmdW5jdGlvbiBjb250aW51ZXMgd2l0aCBzdGFuZGFyZCBzdHJlYW0gcHJvY2Vzc2luZy5cbiAqXG4gKiBGb3Igbm9uLTJ4eCBIVFRQIHJlc3BvbnNlczpcbiAqIC0gSWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgZGVmaW5lZCwgaXQgYXN5bmNocm9ub3VzbHkgZXh0cmFjdHMgYW5kIGRlY29kZXMgdGhlIHJlc3BvbnNlIGJvZHkuXG4gKiAtIEl0IHRoZW4gY3JlYXRlcyBhIGN1c3RvbSBSZWFkYWJsZVN0cmVhbSB0byBwcm9wYWdhdGUgYSBkZXRhaWxlZCBlcnJvciBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlLlxuICogQHBhcmFtIHtBSVN0cmVhbVBhcnNlcn0gY3VzdG9tUGFyc2VyIC0gVGhlIGN1c3RvbSBwYXJzZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9uc30gY2FsbGJhY2tzIC0gVGhlIGNhbGxiYWNrcy5cbiAqIEByZXR1cm4ge1JlYWRhYmxlU3RyZWFtfSBUaGUgQUlTdHJlYW0uXG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHJlc3BvbnNlIGlzIG5vdCBPSy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEFJU3RyZWFtKFxuICByZXNwb25zZTogUmVzcG9uc2UsXG4gIGN1c3RvbVBhcnNlcj86IEFJU3RyZWFtUGFyc2VyLFxuICBjYWxsYmFja3M/OiBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMsXG4pOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PiB7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihgUmVzcG9uc2UgZXJyb3I6ICR7ZXJyb3JUZXh0fWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcignUmVzcG9uc2UgZXJyb3I6IE5vIHJlc3BvbnNlIGJvZHknKSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXNwb25zZUJvZHlTdHJlYW0gPSByZXNwb25zZS5ib2R5IHx8IGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKTtcblxuICByZXR1cm4gcmVzcG9uc2VCb2R5U3RyZWFtXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSlcbiAgICAucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSk7XG59XG5cbi8vIG91dHB1dHMgbGluZXMgbGlrZVxuLy8gMDogY2h1bmtcbi8vIDA6IG1vcmUgY2h1bmtcbi8vIDE6IGEgZmN0IGNhbGxcbi8vIHo6IGFkZGVkIGRhdGEgZnJvbSBEYXRhXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBSZWFkYWJsZVN0cmVhbSB0aGF0IGltbWVkaWF0ZWx5IGNsb3NlcyB1cG9uIGNyZWF0aW9uLlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGFzIGEgZmFsbGJhY2sgZm9yIGNyZWF0aW5nIGEgUmVhZGFibGVTdHJlYW0gd2hlbiB0aGUgcmVzcG9uc2UgYm9keSBpcyBudWxsIG9yIHVuZGVmaW5lZCxcbiAqIGVuc3VyaW5nIHRoYXQgdGhlIHN1YnNlcXVlbnQgcGlwZWxpbmUgcHJvY2Vzc2luZyBkb2Vzbid0IGZhaWwgZHVlIHRvIGEgbGFjayBvZiBhIHN0cmVhbS5cbiAqXG4gKiBAcmV0dXJucyB7UmVhZGFibGVTdHJlYW19IEFuIGVtcHR5IGFuZCBjbG9zZWQgUmVhZGFibGVTdHJlYW0gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKTogUmVhZGFibGVTdHJlYW0ge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBSZWFkYWJsZVN0cmVhbS5mcm9tKGFzeW5jSXRlcmFibGUpLCB3aGljaCBpc24ndCBkb2N1bWVudGVkIGluIE1ETiBhbmQgaXNuJ3QgaW1wbGVtZW50ZWQgaW4gbm9kZS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvc3RyZWFtcy9jb21taXQvOGQ3YTBiZjI2ZWIyY2MyM2U4ODRkZGJhYWM3YzFkYTRiOTFjZjJiY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZTxUPihpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUPikge1xuICBsZXQgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbTxUPih7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgZWxzZSBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICBhd2FpdCBpdC5yZXR1cm4/LihyZWFzb24pO1xuICAgIH0sXG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgSlNPTlZhbHVlLCBmb3JtYXRTdHJlYW1QYXJ0IH0gZnJvbSAnQGFpLXNkay91aS11dGlscyc7XG5cbi8qKlxuICogQSBzdHJlYW0gd3JhcHBlciB0byBzZW5kIGN1c3RvbSBKU09OLWVuY29kZWQgZGF0YSBiYWNrIHRvIHRoZSBjbGllbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1EYXRhIHtcbiAgcHJpdmF0ZSBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbiAgcHJpdmF0ZSBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI8VWludDhBcnJheT4gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIHN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT47XG5cbiAgcHJpdmF0ZSBpc0Nsb3NlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIHdhcm5pbmdUaW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGFzeW5jIGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBzZWxmLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXG4gICAgICAgIC8vIFNldCBhIHRpbWVvdXQgdG8gc2hvdyBhIHdhcm5pbmcgaWYgdGhlIHN0cmVhbSBpcyBub3QgY2xvc2VkIHdpdGhpbiAzIHNlY29uZHNcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgc2VsZi53YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAnVGhlIGRhdGEgc3RyZWFtIGlzIGhhbmdpbmcuIERpZCB5b3UgZm9yZ2V0IHRvIGNsb3NlIGl0IHdpdGggYGRhdGEuY2xvc2UoKWA/JyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwdWxsOiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgLy8gTm8tb3A6IHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgc3BlY2lhbCBvbiBwdWxsXG4gICAgICB9LFxuICAgICAgY2FuY2VsOiByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG5cbiAgICAvLyBDbGVhciB0aGUgd2FybmluZyB0aW1lb3V0IGlmIHRoZSBzdHJlYW0gaXMgY2xvc2VkXG4gICAgaWYgKHRoaXMud2FybmluZ1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhcm5pbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICBhcHBlbmQodmFsdWU6IEpTT05WYWx1ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgnZGF0YScsIFt2YWx1ZV0pKSxcbiAgICApO1xuICB9XG5cbiAgYXBwZW5kTWVzc2FnZUFubm90YXRpb24odmFsdWU6IEpTT05WYWx1ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgnbWVzc2FnZV9hbm5vdGF0aW9ucycsIFt2YWx1ZV0pKSxcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQSBUcmFuc2Zvcm1TdHJlYW0gZm9yIExMTXMgdGhhdCBkbyBub3QgaGF2ZSB0aGVpciBvd24gdHJhbnNmb3JtIHN0cmVhbSBoYW5kbGVycyBtYW5hZ2luZyBlbmNvZGluZyAoZS5nLiBPcGVuQUlTdHJlYW0gaGFzIG9uZSBmb3IgZnVuY3Rpb24gY2FsbCBoYW5kbGluZykuXG4gKiBUaGlzIGFzc3VtZXMgZXZlcnkgY2h1bmsgaXMgYSAndGV4dCcgY2h1bmsuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgndGV4dCcsIG1lc3NhZ2UpKSk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuQGRlcHJlY2F0ZWQgVXNlIGBTdHJlYW1EYXRhYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgY2xhc3MgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEgZXh0ZW5kcyBTdHJlYW1EYXRhIHt9XG4iLCJpbXBvcnQge1xuICBDcmVhdGVNZXNzYWdlLFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgVG9vbENhbGwsXG4gIGNyZWF0ZUNodW5rRGVjb2RlcixcbiAgZm9ybWF0U3RyZWFtUGFydCxcbn0gZnJvbSAnQGFpLXNkay91aS11dGlscyc7XG5pbXBvcnQge1xuICBBSVN0cmVhbSxcbiAgRnVuY3Rpb25DYWxsUGF5bG9hZCxcbiAgVG9vbENhbGxQYXlsb2FkLFxuICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcixcbiAgcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSxcbiAgdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIsXG4gIHR5cGUgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zLFxufSBmcm9tICcuL2FpLXN0cmVhbSc7XG5pbXBvcnQgeyBBenVyZUNoYXRDb21wbGV0aW9ucyB9IGZyb20gJy4vYXp1cmUtb3BlbmFpLXR5cGVzJztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciB9IGZyb20gJy4vc3RyZWFtLWRhdGEnO1xuXG5leHBvcnQgdHlwZSBPcGVuQUlTdHJlYW1DYWxsYmFja3MgPSBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMgJiB7XG4gIC8qKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgbW9kZWw6ICdncHQtMy41LXR1cmJvLTA2MTMnLFxuICAgKiAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICBtZXNzYWdlcyxcbiAgICogICBmdW5jdGlvbnMsXG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnN0IHN0cmVhbSA9IE9wZW5BSVN0cmVhbShyZXNwb25zZSwge1xuICAgKiAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbDogYXN5bmMgKGZ1bmN0aW9uQ2FsbFBheWxvYWQsIGNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzKSA9PiB7XG4gICAqICAgICAvLyAuLi4gcnVuIHlvdXIgY3VzdG9tIGxvZ2ljIGhlcmVcbiAgICogICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG15RnVuY3Rpb24oZnVuY3Rpb25DYWxsUGF5bG9hZClcbiAgICpcbiAgICogICAgIC8vIEFzayBmb3IgYW5vdGhlciBjb21wbGV0aW9uLCBvciByZXR1cm4gYSBzdHJpbmcgdG8gc2VuZCB0byB0aGUgY2xpZW50IGFzIGFuIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgKiAgICAgcmV0dXJuIGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgICAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0wNjEzJyxcbiAgICogICAgICAgc3RyZWFtOiB0cnVlLFxuICAgKiAgICAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IFwiYXNzaXN0YW50XCIgYW5kIFwiZnVuY3Rpb25cIiBjYWxsIG1lc3NhZ2VzXG4gICAqICAgICAgIG1lc3NhZ2VzOiBbLi4ubWVzc2FnZXMsIC4uLmNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzKHJlc3VsdCldLFxuICAgKiAgICAgICBmdW5jdGlvbnMsXG4gICAqICAgICB9KVxuICAgKiAgIH1cbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGw/OiAoXG4gICAgZnVuY3Rpb25DYWxsUGF5bG9hZDogRnVuY3Rpb25DYWxsUGF5bG9hZCxcbiAgICBjcmVhdGVGdW5jdGlvbkNhbGxNZXNzYWdlczogKFxuICAgICAgZnVuY3Rpb25DYWxsUmVzdWx0OiBKU09OVmFsdWUsXG4gICAgKSA9PiBDcmVhdGVNZXNzYWdlW10sXG4gICkgPT4gUHJvbWlzZTxcbiAgICBSZXNwb25zZSB8IHVuZGVmaW5lZCB8IHZvaWQgfCBzdHJpbmcgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXNcbiAgPjtcbiAgLyoqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICogICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8tMTEwNicsIC8vIG9yIGdwdC00LTExMDYtcHJldmlld1xuICAgKiAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICBtZXNzYWdlcyxcbiAgICogICB0b29scyxcbiAgICogICB0b29sX2Nob2ljZTogXCJhdXRvXCIsIC8vIGF1dG8gaXMgZGVmYXVsdCwgYnV0IHdlJ2xsIGJlIGV4cGxpY2l0XG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnN0IHN0cmVhbSA9IE9wZW5BSVN0cmVhbShyZXNwb25zZSwge1xuICAgKiAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOiBhc3luYyAodG9vbENhbGxQYXlsb2FkLCBhcHBlbmRUb29sQ2FsbE1lc3NhZ2VzKSA9PiB7XG4gICAqICAgIGxldCBtZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID0gW11cbiAgICogICAgLy8gICBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSB0b29sIGNhbGxzLCBzbyB3ZSBuZWVkIHRvIGl0ZXJhdGUgdGhyb3VnaCB0aGVtXG4gICAqICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29sQ2FsbFBheWxvYWQudG9vbHMpIHtcbiAgICogICAgIC8vIC4uLiBydW4geW91ciBjdXN0b20gbG9naWMgaGVyZVxuICAgKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbXlGdW5jdGlvbih0b29sLmZ1bmN0aW9uKVxuICAgKiAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IFwiYXNzaXN0YW50XCIgYW5kIFwidG9vbFwiIGNhbGwgbWVzc2FnZXNcbiAgICogICAgIGFwcGVuZFRvb2xDYWxsTWVzc2FnZSh7dG9vbF9jYWxsX2lkOnRvb2wuaWQsIGZ1bmN0aW9uX25hbWU6dG9vbC5mdW5jdGlvbi5uYW1lLCB0b29sX2NhbGxfcmVzdWx0OnJlc3VsdH0pXG4gICAqICAgIH1cbiAgICogICAgIC8vIEFzayBmb3IgYW5vdGhlciBjb21wbGV0aW9uLCBvciByZXR1cm4gYSBzdHJpbmcgdG8gc2VuZCB0byB0aGUgY2xpZW50IGFzIGFuIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgKiAgICAgcmV0dXJuIGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgICAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0xMTA2JywgLy8gb3IgZ3B0LTQtMTEwNi1wcmV2aWV3XG4gICAqICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICAgICAgLy8gQXBwZW5kIHRoZSByZXN1bHRzIG1lc3NhZ2VzLCBjYWxsaW5nIGFwcGVuZFRvb2xDYWxsTWVzc2FnZSB3aXRob3V0XG4gICAqICAgICAgIC8vIGFueSBhcmd1bWVudHMgd2lsbCBqc3V0IHJldHVybiB0aGUgYWNjdW11bGF0ZWQgbWVzc2FnZXNcbiAgICogICAgICAgbWVzc2FnZXM6IFsuLi5tZXNzYWdlcywgLi4uYXBwZW5kVG9vbENhbGxNZXNzYWdlKCldLFxuICAgKiAgICAgICB0b29scyxcbiAgICogICAgICAgIHRvb2xfY2hvaWNlOiBcImF1dG9cIiwgLy8gYXV0byBpcyBkZWZhdWx0LCBidXQgd2UnbGwgYmUgZXhwbGljaXRcbiAgICogICAgIH0pXG4gICAqICAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsPzogKFxuICAgIHRvb2xDYWxsUGF5bG9hZDogVG9vbENhbGxQYXlsb2FkLFxuICAgIGFwcGVuZFRvb2xDYWxsTWVzc2FnZTogKHJlc3VsdD86IHtcbiAgICAgIHRvb2xfY2FsbF9pZDogc3RyaW5nO1xuICAgICAgZnVuY3Rpb25fbmFtZTogc3RyaW5nO1xuICAgICAgdG9vbF9jYWxsX3Jlc3VsdDogSlNPTlZhbHVlO1xuICAgIH0pID0+IENyZWF0ZU1lc3NhZ2VbXSxcbiAgKSA9PiBQcm9taXNlPFxuICAgIFJlc3BvbnNlIHwgdW5kZWZpbmVkIHwgdm9pZCB8IHN0cmluZyB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlc1xuICA+O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iLzA3YjM1MDRlMWM0MGZkOTI5ZjRhYWUxNjUxYjgzYWZjMTllM2JhZjgvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzI0wyOC1MNDBcbmludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rIHtcbiAgaWQ6IHN0cmluZztcbiAgY2hvaWNlczogQXJyYXk8Q2hhdENvbXBsZXRpb25DaHVua0Nob2ljZT47XG4gIGNyZWF0ZWQ6IG51bWJlcjtcbiAgbW9kZWw6IHN0cmluZztcbiAgb2JqZWN0OiBzdHJpbmc7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMNDMtTDQ5XG4vLyBVcGRhdGVkIGZvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2NvbW1pdC9mMTBjNzU3ZDgzMWQ5MDQwN2JhNDdiNDY1OWQ5Y2QzNGIxYTM1YjFkXG4vLyBVcGRhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0Lzg0YjQzMjgwMDg5ZWFjZGYxOGYxNzE3MjM1OTE4NTY4MTFiZWRkY2VcbmludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rQ2hvaWNlIHtcbiAgZGVsdGE6IENob2ljZURlbHRhO1xuICBmaW5pc2hfcmVhc29uOlxuICAgIHwgJ3N0b3AnXG4gICAgfCAnbGVuZ3RoJ1xuICAgIHwgJ3Rvb2xfY2FsbHMnXG4gICAgfCAnY29udGVudF9maWx0ZXInXG4gICAgfCAnZnVuY3Rpb25fY2FsbCdcbiAgICB8IG51bGw7XG4gIGluZGV4OiBudW1iZXI7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMMTIzLUwxMzlcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIENob2ljZURlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgY2h1bmsgbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAqIG1vZGVsLlxuICAgKi9cbiAgZnVuY3Rpb25fY2FsbD86IEZ1bmN0aW9uQ2FsbDtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuXG4gICAqL1xuICByb2xlPzogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JyB8ICd0b29sJztcblxuICB0b29sX2NhbGxzPzogQXJyYXk8RGVsdGFUb29sQ2FsbD47XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHNcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIERlbHRhVG9vbENhbGwge1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB0aGUgbW9kZWwgY2FsbGVkLlxuICAgKi9cbiAgZnVuY3Rpb24/OiBUb29sQ2FsbEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gQ3VycmVudGx5LCBvbmx5IGBmdW5jdGlvbmAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgdHlwZT86ICdmdW5jdGlvbic7XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHNcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIFRvb2xDYWxsRnVuY3Rpb24ge1xuICAvKipcbiAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAqL1xuICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvM2VjNDNlZTc5MGEyZWI2YTBjY2RkNWYyNWZhYTIzMjUxYjBmOWI4ZS9zcmMvcmVzb3VyY2VzL2NvbXBsZXRpb25zLnRzI0wyOEMxLUw2NEMxXG4gKiBDb21wbGV0aW9ucyBBUEkuIFN0cmVhbWVkIGFuZCBub24tc3RyZWFtZWQgcmVzcG9uc2VzIGFyZSB0aGUgc2FtZS5cbiAqL1xuaW50ZXJmYWNlIENvbXBsZXRpb24ge1xuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBjb21wbGV0aW9uIGNob2ljZXMgdGhlIG1vZGVsIGdlbmVyYXRlZCBmb3IgdGhlIGlucHV0IHByb21wdC5cbiAgICovXG4gIGNob2ljZXM6IEFycmF5PENvbXBsZXRpb25DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgY29tcGxldGlvbiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHVzZWQgZm9yIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcInRleHRfY29tcGxldGlvblwiXG4gICAqL1xuICBvYmplY3Q6IHN0cmluZztcblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGNvbXBsZXRpb24gcmVxdWVzdC5cbiAgICovXG4gIHVzYWdlPzogQ29tcGxldGlvblVzYWdlO1xufVxuXG5pbnRlcmZhY2UgQ29tcGxldGlvbkNob2ljZSB7XG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBvciBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZC5cbiAgICovXG4gIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ2NvbnRlbnRfZmlsdGVyJztcblxuICBpbmRleDogbnVtYmVyO1xuXG4gIC8vIGVkaXRlZDogUmVtb3ZlZCBDb21wbGV0aW9uQ2hvaWNlLmxvZ1Byb2JzIGFuZCByZXBsYWNlZCB3aXRoIGFueVxuICBsb2dwcm9iczogYW55IHwgbnVsbDtcblxuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvblVzYWdlIHtcbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnZW5lcmF0ZWQgY29tcGxldGlvbi5cbiAgICovXG4gIGNvbXBsZXRpb25fdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiB0b2tlbnMgaW4gdGhlIHByb21wdC5cbiAgICovXG4gIHByb21wdF90b2tlbnM6IG51bWJlcjtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSByZXF1ZXN0IChwcm9tcHQgKyBjb21wbGV0aW9uKS5cbiAgICovXG4gIHRvdGFsX3Rva2VuczogbnVtYmVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwYXJzZXIgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgdGhlIE9wZW5BSSBzdHJlYW0gZGF0YS5cbiAqIFRoZSBwYXJzZXIgZXh0cmFjdHMgYW5kIHRyaW1zIHRleHQgY29udGVudCBmcm9tIHRoZSBKU09OIGRhdGEuIFRoaXMgcGFyc2VyXG4gKiBjYW4gaGFuZGxlIGRhdGEgZm9yIGNoYXQgb3IgY29tcGxldGlvbiBtb2RlbHMuXG4gKlxuICogQHJldHVybiB7KGRhdGE6IHN0cmluZykgPT4gc3RyaW5nIHwgdm9pZHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfX1cbiAqIEEgcGFyc2VyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBKU09OIHN0cmluZyBhcyBpbnB1dCBhbmQgcmV0dXJucyB0aGUgZXh0cmFjdGVkIHRleHQgY29udGVudCxcbiAqIGEgY29tcGxleCBvYmplY3Qgd2l0aCBpc1RleHQ6IGZhbHNlIGZvciBmdW5jdGlvbi90b29sIGNhbGxzLCBvciBub3RoaW5nLlxuICovXG5mdW5jdGlvbiBwYXJzZU9wZW5BSVN0cmVhbSgpOiAoXG4gIGRhdGE6IHN0cmluZyxcbikgPT4gc3RyaW5nIHwgdm9pZCB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0ge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgcmV0dXJuIGRhdGEgPT4gZXh0cmFjdChKU09OLnBhcnNlKGRhdGEpIGFzIE9wZW5BSVN0cmVhbVJldHVyblR5cGVzKTtcbn1cblxuLyoqXG4gKiBSZWFkcyBjaHVua3MgZnJvbSBPcGVuQUkncyBuZXcgU3RyZWFtYWJsZSBpbnRlcmZhY2UsIHdoaWNoIGlzIGVzc2VudGlhbGx5XG4gKiB0aGUgc2FtZSBhcyB0aGUgb2xkIFJlc3BvbnNlIGJvZHkgaW50ZXJmYWNlIHdpdGggYW4gaW5jbHVkZWQgU1NFIHBhcnNlclxuICogZG9pbmcgdGhlIHBhcnNpbmcgZm9yIHVzLlxuICovXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZShzdHJlYW06IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcykge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcblxuICBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAvLyBjb252ZXJ0IGNodW5rIGlmIGl0IGlzIGFuIEF6dXJlIGNoYXQgY29tcGxldGlvbi4gQXp1cmUgZG9lcyBub3QgZXhwb3NlIGFsbFxuICAgIC8vIHByb3BlcnRpZXMgaW4gdGhlIGludGVyZmFjZXMsIGFuZCBhbHNvIHVzZXMgY2FtZWxDYXNlIGluc3RlYWQgb2Ygc25ha2VfY2FzZVxuICAgIGlmICgncHJvbXB0RmlsdGVyUmVzdWx0cycgaW4gY2h1bmspIHtcbiAgICAgIGNodW5rID0ge1xuICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgIGNyZWF0ZWQ6IGNodW5rLmNyZWF0ZWQuZ2V0RGF0ZSgpLFxuICAgICAgICBvYmplY3Q6IChjaHVuayBhcyBhbnkpLm9iamVjdCwgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIG1vZGVsOiAoY2h1bmsgYXMgYW55KS5tb2RlbCwgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIGNob2ljZXM6IGNodW5rLmNob2ljZXMubWFwKGNob2ljZSA9PiAoe1xuICAgICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgICBjb250ZW50OiBjaG9pY2UuZGVsdGE/LmNvbnRlbnQsXG4gICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaG9pY2UuZGVsdGE/LmZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgIHJvbGU6IGNob2ljZS5kZWx0YT8ucm9sZSBhcyBhbnksXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBjaG9pY2UuZGVsdGE/LnRvb2xDYWxscz8ubGVuZ3RoXG4gICAgICAgICAgICAgID8gY2hvaWNlLmRlbHRhPy50b29sQ2FsbHM/Lm1hcCgodG9vbENhbGwsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICB0eXBlOiB0b29sQ2FsbC50eXBlLFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbmlzaF9yZWFzb246IGNob2ljZS5maW5pc2hSZWFzb24gYXMgYW55LFxuICAgICAgICAgIGluZGV4OiBjaG9pY2UuaW5kZXgsXG4gICAgICAgIH0pKSxcbiAgICAgIH0gc2F0aXNmaWVzIENoYXRDb21wbGV0aW9uQ2h1bms7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IGV4dHJhY3QoY2h1bmspO1xuXG4gICAgaWYgKHRleHQpIHlpZWxkIHRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2h1bmtUb1RleHQoKTogKFxuICBjaHVuazogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMsXG4pID0+IHN0cmluZyB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0gfCB2b2lkIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luOiBib29sZWFuO1xuICByZXR1cm4ganNvbiA9PiB7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSBqc29uLmNob2ljZXNbMF0/LmRlbHRhO1xuICAgICAgaWYgKGRlbHRhLmZ1bmN0aW9uX2NhbGw/Lm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCIke2RlbHRhLmZ1bmN0aW9uX2NhbGwubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gZGVsdGEudG9vbF9jYWxsc1swXTtcbiAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBge1widG9vbF9jYWxsc1wiOlsge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIke3Rvb2xDYWxsLmZ1bmN0aW9uPy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImAsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcIn19LCB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7dG9vbENhbGwuZnVuY3Rpb24/Lm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhLmZ1bmN0aW9uX2NhbGw/LmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cyhkZWx0YS5mdW5jdGlvbl9jYWxsPy5hcmd1bWVudHMpLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoZGVsdGEudG9vbF9jYWxscz8uWzBdPy5mdW5jdGlvbj8uYXJndW1lbnRzKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICAoanNvbi5jaG9pY2VzWzBdPy5maW5pc2hfcmVhc29uID09PSAnZnVuY3Rpb25fY2FsbCcgfHxcbiAgICAgICAgICBqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICdzdG9wJylcbiAgICAgICkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTsgLy8gUmVzZXQgdGhlIGZsYWdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19JyxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICBqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICd0b29sX2NhbGxzJ1xuICAgICAgKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlOyAvLyBSZXNldCB0aGUgZmxhZ1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX1dfScsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKFxuICAgICAgaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmIGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50XG4gICAgICAgID8ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnRcbiAgICAgICAgOiBpc0NvbXBsZXRpb24oanNvbilcbiAgICAgICAgPyBqc29uLmNob2ljZXNbMF0udGV4dFxuICAgICAgICA6ICcnLFxuICAgICk7XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICBmdW5jdGlvbiBjbGVhbnVwQXJndW1lbnRzKGFyZ3VtZW50Q2h1bms6IHN0cmluZykge1xuICAgIGxldCBlc2NhcGVkUGFydGlhbEpzb24gPSBhcmd1bWVudENodW5rXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKSAvLyBSZXBsYWNlIGJhY2tzbGFzaGVzIGZpcnN0IHRvIHByZXZlbnQgZG91YmxlIGVzY2FwaW5nXG4gICAgICAucmVwbGFjZSgvXFwvL2csICdcXFxcLycpIC8vIEVzY2FwZSBzbGFzaGVzXG4gICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpIC8vIEVzY2FwZSBkb3VibGUgcXVvdGVzXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpIC8vIEVzY2FwZSBuZXcgbGluZXNcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgLy8gRXNjYXBlIGNhcnJpYWdlIHJldHVybnNcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykgLy8gRXNjYXBlIHRhYnNcbiAgICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJyk7IC8vIEVzY2FwZSBmb3JtIGZlZWRzXG5cbiAgICByZXR1cm4gYCR7ZXNjYXBlZFBhcnRpYWxKc29ufWA7XG4gIH1cbn1cblxuY29uc3QgX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCA9IFN5bWJvbChcbiAgJ2ludGVybmFsX29wZW5haV9mbl9tZXNzYWdlcycsXG4pO1xuXG50eXBlIEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyA9XG4gIHwgQXN5bmNJdGVyYWJsZTxDaGF0Q29tcGxldGlvbkNodW5rPlxuICB8IEFzeW5jSXRlcmFibGU8Q29tcGxldGlvbj5cbiAgfCBBc3luY0l0ZXJhYmxlPEF6dXJlQ2hhdENvbXBsZXRpb25zPjtcblxudHlwZSBFeHRyYWN0VHlwZTxUPiA9IFQgZXh0ZW5kcyBBc3luY0l0ZXJhYmxlPGluZmVyIFU+ID8gVSA6IG5ldmVyO1xuXG50eXBlIE9wZW5BSVN0cmVhbVJldHVyblR5cGVzID1cbiAgRXh0cmFjdFR5cGU8QXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzPjtcblxuZnVuY3Rpb24gaXNDaGF0Q29tcGxldGlvbkNodW5rKFxuICBkYXRhOiBPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyxcbik6IGRhdGEgaXMgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIHJldHVybiAoXG4gICAgJ2Nob2ljZXMnIGluIGRhdGEgJiZcbiAgICBkYXRhLmNob2ljZXMgJiZcbiAgICBkYXRhLmNob2ljZXNbMF0gJiZcbiAgICAnZGVsdGEnIGluIGRhdGEuY2hvaWNlc1swXVxuICApO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBsZXRpb24oZGF0YTogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMpOiBkYXRhIGlzIENvbXBsZXRpb24ge1xuICByZXR1cm4gKFxuICAgICdjaG9pY2VzJyBpbiBkYXRhICYmXG4gICAgZGF0YS5jaG9pY2VzICYmXG4gICAgZGF0YS5jaG9pY2VzWzBdICYmXG4gICAgJ3RleHQnIGluIGRhdGEuY2hvaWNlc1swXVxuICApO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgW09wZW5BSSBwcm92aWRlcl0oaHR0cHM6Ly9zZGsudmVyY2VsLmFpL3Byb3ZpZGVycy9haS1zZGstcHJvdmlkZXJzL29wZW5haSkgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE9wZW5BSVN0cmVhbShcbiAgcmVzOiBSZXNwb25zZSB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyxcbiAgY2FsbGJhY2tzPzogT3BlbkFJU3RyZWFtQ2FsbGJhY2tzLFxuKTogUmVhZGFibGVTdHJlYW0ge1xuICAvLyBBbm5vdGF0ZSB0aGUgaW50ZXJuYWwgYG1lc3NhZ2VzYCBwcm9wZXJ0eSBmb3IgcmVjdXJzaXZlIGZ1bmN0aW9uIGNhbGxzXG4gIGNvbnN0IGNiOlxuICAgIHwgdW5kZWZpbmVkXG4gICAgfCAoT3BlbkFJU3RyZWFtQ2FsbGJhY2tzICYge1xuICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0/OiBDcmVhdGVNZXNzYWdlW107XG4gICAgICB9KSA9IGNhbGxiYWNrcztcblxuICBsZXQgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PjtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHN0cmVhbSA9IHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZShyZXMpKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKFxuICAgICAgICBjYj8uZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiPy5leHBlcmltZW50YWxfb25Ub29sQ2FsbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICAgICAgb25GaW5hbDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICAgIH0sXG4gICAgICApLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gQUlTdHJlYW0oXG4gICAgICByZXMsXG4gICAgICBwYXJzZU9wZW5BSVN0cmVhbSgpLFxuICAgICAgY2I/LmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYj8uZXhwZXJpbWVudGFsX29uVG9vbENhbGxcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICAgIG9uRmluYWw6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgaWYgKGNiICYmIChjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgY29uc3QgZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIgPSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYik7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoXG4gIGNhbGxiYWNrczogT3BlbkFJU3RyZWFtQ2FsbGJhY2tzICYge1xuICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXT86IENyZWF0ZU1lc3NhZ2VbXTtcbiAgfSxcbik6IFRyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBVaW50OEFycmF5PiB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gJyc7XG4gIGxldCBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSAnJztcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuXG4gIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID1cbiAgICBjYWxsYmFja3NbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0gfHwgW107XG5cbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZShjaHVuayk7XG4gICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgKz0gbWVzc2FnZTtcblxuICAgICAgY29uc3Qgc2hvdWxkSGFuZGxlQXNGdW5jdGlvbiA9XG4gICAgICAgIGlzRmlyc3RDaHVuayAmJlxuICAgICAgICAobWVzc2FnZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykgfHxcbiAgICAgICAgICBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSk7XG5cbiAgICAgIGlmIChzaG91bGRIYW5kbGVBc0Z1bmN0aW9uKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTdHJlYW0gYXMgbm9ybWFsXG4gICAgICBpZiAoIWlzRnVuY3Rpb25TdHJlYW1pbmdJbikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoJ3RleHQnLCBtZXNzYWdlKSksXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpc0ZpcnN0Q2h1bmsgJiZcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiZcbiAgICAgICAgICAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fFxuICAgICAgICAgICAgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKVxuICAgICAgICApIHtcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCBtZXNzYWdlIHRvIHRoZSBsaXN0XG4gICAgICAgICAgbGV0IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzOiBDcmVhdGVNZXNzYWdlW10gPSBbXG4gICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2U6XG4gICAgICAgICAgICB8IFJlc3BvbnNlXG4gICAgICAgICAgICB8IHVuZGVmaW5lZFxuICAgICAgICAgICAgfCB2b2lkXG4gICAgICAgICAgICB8IHN0cmluZ1xuICAgICAgICAgICAgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXNcbiAgICAgICAgICAgIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIC8vIFRoaXMgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBjaGVjayBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBidXQgVFMgY29tcGxhaW5zXG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIHVzaW5nIHRoZSBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgY2FsbGJhY2ssIHRoZXkgc2hvdWxkIG5vdCBiZSB1c2luZyB0b29sc1xuICAgICAgICAgICAgLy8gaWYgcGF5bG9hZC5mdW5jdGlvbl9jYWxsIGlzIG5vdCBkZWZpbmVkIGJ5IHRpbWUgd2UgZ2V0IGhlcmUgd2UgbXVzdCBoYXZlIGdvdHRlbiBhIHRvb2wgcmVzcG9uc2VcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgdXNlciBoYWQgZGVmaW5lZCBleHBlcmltZW50YWxfb25Ub29sQ2FsbFxuICAgICAgICAgICAgaWYgKHBheWxvYWQuZnVuY3Rpb25fY2FsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzUGF5bG9hZCA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzUGF5bG9hZCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVxdWVzdCBhbmQgcmVzdWx0IG1lc3NhZ2VzIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gaXQgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHM6IFRvb2xDYWxsUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgdG9vbHM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiBwYXlsb2FkLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgdG9vbENhbGxzLnRvb2xzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiB0b29sLmlkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgZnVuYzoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnBhcnNlKHRvb2wuZnVuY3Rpb24uYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwoXG4gICAgICAgICAgICAgICAgdG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9vbF9jYWxsX2lkLCBmdW5jdGlvbl9uYW1lLCB0b29sX2NhbGxfcmVzdWx0IH0gPVxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlcXVlc3QgYW5kIHJlc3VsdCBtZXNzYWdlcyB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5uZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGVuZCB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaWYgaXQncyB0aGUgZmlyc3QgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAuLi4ocmVzcG9uc2VJbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcgYXMgY29uc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHBheWxvYWQudG9vbF9jYWxscy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YzogVG9vbENhbGwpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRjLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRjLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgYW4gb2JqZWN0IHRvIHRoZSB1c2VyLCBidXQgYXMgdGhlIEFQSSBleHBlY3RzIGEgc3RyaW5nLCB3ZSBuZWVkIHRvIHN0cmluZ2lmeSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGMuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlc3VsdCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3Rvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHRvb2xfY2FsbF9yZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBpdCB0byB0aGUgdXNlclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGxpbmcgZXhwZXJpbWVudGFsX29uVG9vbENhbGw6JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFmdW5jdGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXNlciBkaWRuJ3QgZG8gYW55dGhpbmcgd2l0aCB0aGUgZnVuY3Rpb24gY2FsbCBvbiB0aGUgc2VydmVyIGFuZCB3YW50c1xuICAgICAgICAgICAgLy8gdG8gZWl0aGVyIGRvIG5vdGhpbmcgb3IgcnVuIGl0IG9uIHRoZSBjbGllbnRcbiAgICAgICAgICAgIC8vIHNvIHdlIGp1c3QgcmV0dXJuIHRoZSBmdW5jdGlvbiBjYWxsIGFzIGEgbWVzc2FnZVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbCA/ICdmdW5jdGlvbl9jYWxsJyA6ICd0b29sX2NhbGxzJyxcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRvIHByZXZlbnQgZG91YmxlLWVuY29kaW5nOlxuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXNlciByZXR1cm5lZCBhIHN0cmluZywgc28gd2UganVzdCByZXR1cm4gaXQgYXMgYSBtZXNzYWdlXG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KCd0ZXh0JywgZnVuY3Rpb25SZXNwb25zZSkpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IGZ1bmN0aW9uUmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHk6XG5cbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgb25TdGFydCBvciBvbkNvbXBsZXRlIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgLy8gc28gd2UgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgY2FsbGJhY2tzXG4gICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvYWkvaXNzdWVzLzM1MVxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ2FsbGJhY2tzOiBPcGVuQUlTdHJlYW1DYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAuLi5jYWxsYmFja3MsXG4gICAgICAgICAgICBvblN0YXJ0OiB1bmRlZmluZWQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgb25GaW5hbCB0byBiZSBjYWxsZWQgdGhlIF9sYXN0XyB0aW1lXG4gICAgICAgICAgY2FsbGJhY2tzLm9uRmluYWwgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBjb25zdCBvcGVuQUlTdHJlYW0gPSBPcGVuQUlTdHJlYW0oZnVuY3Rpb25SZXNwb25zZSwge1xuICAgICAgICAgICAgLi4uZmlsdGVyZWRDYWxsYmFja3MsXG4gICAgICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF06IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgIH0gYXMgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zKTtcblxuICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG9wZW5BSVN0cmVhbS5nZXRSZWFkZXIoKTtcblxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSkge1xuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbn1cbiIsImV4cG9ydCBjb25zdCBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUgPSBTeW1ib2wuZm9yKCd1aS5zdHJlYW1hYmxlLnZhbHVlJyk7XG5leHBvcnQgY29uc3QgREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUgPSAxNSAqIDEwMDA7XG4iLCJpbXBvcnQge1xuICBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yLFxuICBMYW5ndWFnZU1vZGVsVjEsXG4gIE5vU3VjaFRvb2xFcnJvcixcbn0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcblxuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXItdXRpbHMnO1xuaW1wb3J0IHsgQ2FsbFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvY2FsbC1zZXR0aW5ncyc7XG5pbXBvcnQgeyBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0IH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQnO1xuaW1wb3J0IHsgZ2V0VmFsaWRhdGVkUHJvbXB0IH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvZ2V0LXZhbGlkYXRlZC1wcm9tcHQnO1xuaW1wb3J0IHsgcHJlcGFyZUNhbGxTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncyc7XG5pbXBvcnQgeyBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlIH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UnO1xuaW1wb3J0IHsgUHJvbXB0IH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvcHJvbXB0JztcbmltcG9ydCB7IENvcmVUb29sQ2hvaWNlIH0gZnJvbSAnLi4vLi4vY29yZS90eXBlcyc7XG5pbXBvcnQgeyByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmJztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbWFibGVVSSB9IGZyb20gJy4uL3N0cmVhbWFibGUnO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UgfSBmcm9tICcuLi91dGlscyc7XG5cbnR5cGUgU3RyZWFtYWJsZSA9IFJlYWN0Tm9kZSB8IFByb21pc2U8UmVhY3ROb2RlPjtcblxudHlwZSBSZW5kZXJlcjxUIGV4dGVuZHMgQXJyYXk8YW55Pj4gPSAoXG4gIC4uLmFyZ3M6IFRcbikgPT5cbiAgfCBTdHJlYW1hYmxlXG4gIHwgR2VuZXJhdG9yPFN0cmVhbWFibGUsIFN0cmVhbWFibGUsIHZvaWQ+XG4gIHwgQXN5bmNHZW5lcmF0b3I8U3RyZWFtYWJsZSwgU3RyZWFtYWJsZSwgdm9pZD47XG5cbnR5cGUgUmVuZGVyVG9vbDxQQVJBTUVURVJTIGV4dGVuZHMgei5ab2RUeXBlQW55ID0gYW55PiA9IHtcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIHBhcmFtZXRlcnM6IFBBUkFNRVRFUlM7XG4gIGdlbmVyYXRlPzogUmVuZGVyZXI8XG4gICAgW1xuICAgICAgei5pbmZlcjxQQVJBTUVURVJTPixcbiAgICAgIHtcbiAgICAgICAgdG9vbE5hbWU6IHN0cmluZztcbiAgICAgICAgdG9vbENhbGxJZDogc3RyaW5nO1xuICAgICAgfSxcbiAgICBdXG4gID47XG59O1xuXG50eXBlIFJlbmRlclRleHQgPSBSZW5kZXJlcjxcbiAgW1xuICAgIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGZ1bGwgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNvIGZhci5cbiAgICAgICAqL1xuICAgICAgY29udGVudDogc3RyaW5nO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmV3IGFwcGVuZGVkIHRleHQgY29udGVudCBmcm9tIHRoZSBtb2RlbCBzaW5jZSB0aGUgbGFzdCBgdGV4dGAgY2FsbC5cbiAgICAgICAqL1xuICAgICAgZGVsdGE6IHN0cmluZztcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0aGUgbW9kZWwgaXMgZG9uZSBnZW5lcmF0aW5nIHRleHQuXG4gICAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBgY29udGVudGAgd2lsbCBiZSB0aGUgZmluYWwgb3V0cHV0IGFuZCB0aGlzIGNhbGwgd2lsbCBiZSB0aGUgbGFzdC5cbiAgICAgICAqL1xuICAgICAgZG9uZTogYm9vbGVhbjtcbiAgICB9LFxuICBdXG4+O1xuXG50eXBlIFJlbmRlclJlc3VsdCA9IHtcbiAgdmFsdWU6IFJlYWN0Tm9kZTtcbn0gJiBBd2FpdGVkPFJldHVyblR5cGU8TGFuZ3VhZ2VNb2RlbFYxWydkb1N0cmVhbSddPj47XG5cbmNvbnN0IGRlZmF1bHRUZXh0UmVuZGVyZXI6IFJlbmRlclRleHQgPSAoeyBjb250ZW50IH06IHsgY29udGVudDogc3RyaW5nIH0pID0+XG4gIGNvbnRlbnQ7XG5cbi8qKlxuICogYHN0cmVhbVVJYCBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzdHJlYW1hYmxlIFVJIGZyb20gTExNcy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVVJPFxuICBUT09MUyBleHRlbmRzIHsgW25hbWU6IHN0cmluZ106IHouWm9kVHlwZUFueSB9ID0ge30sXG4+KHtcbiAgbW9kZWwsXG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBpbml0aWFsLFxuICB0ZXh0LFxuICAuLi5zZXR0aW5nc1xufTogQ2FsbFNldHRpbmdzICZcbiAgUHJvbXB0ICYge1xuICAgIC8qKlxuICAgICAqIFRoZSBsYW5ndWFnZSBtb2RlbCB0byB1c2UuXG4gICAgICovXG4gICAgbW9kZWw6IExhbmd1YWdlTW9kZWxWMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b29scyB0aGF0IHRoZSBtb2RlbCBjYW4gY2FsbC4gVGhlIG1vZGVsIG5lZWRzIHRvIHN1cHBvcnQgY2FsbGluZyB0b29scy5cbiAgICAgKi9cbiAgICB0b29scz86IHtcbiAgICAgIFtuYW1lIGluIGtleW9mIFRPT0xTXTogUmVuZGVyVG9vbDxUT09MU1tuYW1lXT47XG4gICAgfTtcblxuICAgIC8qKlxuVGhlIHRvb2wgY2hvaWNlIHN0cmF0ZWd5LiBEZWZhdWx0OiAnYXV0bycuXG4gICAgICovXG4gICAgdG9vbENob2ljZT86IENvcmVUb29sQ2hvaWNlPFRPT0xTPjtcblxuICAgIHRleHQ/OiBSZW5kZXJUZXh0O1xuICAgIGluaXRpYWw/OiBSZWFjdE5vZGU7XG4gIH0pOiBQcm9taXNlPFJlbmRlclJlc3VsdD4ge1xuICAvLyBUT0RPOiBSZW1vdmUgdGhlc2UgZXJyb3JzIGFmdGVyIHRoZSBleHBlcmltZW50YWwgcGhhc2UuXG4gIGlmICh0eXBlb2YgbW9kZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2Btb2RlbGAgY2Fubm90IGJlIGEgc3RyaW5nIGluIGBzdHJlYW1VSWAuIFVzZSB0aGUgYWN0dWFsIG1vZGVsIGluc3RhbmNlIGluc3RlYWQuJyxcbiAgICApO1xuICB9XG4gIGlmICgnZnVuY3Rpb25zJyBpbiBzZXR0aW5ncykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgZnVuY3Rpb25zYCBpcyBub3Qgc3VwcG9ydGVkIGluIGBzdHJlYW1VSWAsIHVzZSBgdG9vbHNgIGluc3RlYWQuJyxcbiAgICApO1xuICB9XG4gIGlmICgncHJvdmlkZXInIGluIHNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2Bwcm92aWRlcmAgaXMgbm8gbG9uZ2VyIG5lZWRlZCBpbiBgc3RyZWFtVUlgLiBVc2UgYG1vZGVsYCBpbnN0ZWFkLicsXG4gICAgKTtcbiAgfVxuICBpZiAodG9vbHMpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB0b29sXSBvZiBPYmplY3QuZW50cmllcyh0b29scykpIHtcbiAgICAgIGlmICgncmVuZGVyJyBpbiB0b29sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVG9vbCBkZWZpbml0aW9uIGluIGBzdHJlYW1VSWAgc2hvdWxkIG5vdCBoYXZlIGByZW5kZXJgIHByb3BlcnR5LiBVc2UgYGdlbmVyYXRlYCBpbnN0ZWFkLiBGb3VuZCBpbiB0b29sOiAnICtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdWkgPSBjcmVhdGVTdHJlYW1hYmxlVUkoaW5pdGlhbCk7XG5cbiAgLy8gVGhlIGRlZmF1bHQgdGV4dCByZW5kZXJlciBqdXN0IHJldHVybnMgdGhlIGNvbnRlbnQgYXMgc3RyaW5nLlxuICBjb25zdCB0ZXh0UmVuZGVyID0gdGV4dCB8fCBkZWZhdWx0VGV4dFJlbmRlcmVyO1xuXG4gIGxldCBmaW5pc2hlZDogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVSZW5kZXIoXG4gICAgYXJnczogW3BheWxvYWQ6IGFueV0gfCBbcGF5bG9hZDogYW55LCBvcHRpb25zOiBhbnldLFxuICAgIHJlbmRlcmVyOiB1bmRlZmluZWQgfCBSZW5kZXJlcjxhbnk+LFxuICAgIHJlczogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlU3RyZWFtYWJsZVVJPixcbiAgICBsYXN0Q2FsbCA9IGZhbHNlLFxuICApIHtcbiAgICBpZiAoIXJlbmRlcmVyKSByZXR1cm47XG5cbiAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8dm9pZD4oKTtcblxuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgZmluaXNoZWQgPSBmaW5pc2hlZC50aGVuKCgpID0+IHJlc29sdmFibGUucHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaGVkID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gcmVuZGVyZXIoLi4uYXJncyk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlIHx8XG4gICAgICAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndGhlbicgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgKSB7XG4gICAgICBjb25zdCBub2RlID0gYXdhaXQgKHZhbHVlIGFzIFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPik7XG5cbiAgICAgIGlmIChsYXN0Q2FsbCkge1xuICAgICAgICByZXMuZG9uZShub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcy51cGRhdGUobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB2YWx1ZSAmJlxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gdmFsdWVcbiAgICApIHtcbiAgICAgIGNvbnN0IGl0ID0gdmFsdWUgYXMgQXN5bmNHZW5lcmF0b3I8XG4gICAgICAgIFJlYWN0LlJlYWN0Tm9kZSxcbiAgICAgICAgUmVhY3QuUmVhY3ROb2RlLFxuICAgICAgICB2b2lkXG4gICAgICA+O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgICBpZiAobGFzdENhbGwgJiYgZG9uZSkge1xuICAgICAgICAgIHJlcy5kb25lKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlIGFzIEdlbmVyYXRvcjxSZWFjdC5SZWFjdE5vZGUsIFJlYWN0LlJlYWN0Tm9kZSwgdm9pZD47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpdC5uZXh0KCk7XG4gICAgICAgIGlmIChsYXN0Q2FsbCAmJiBkb25lKSB7XG4gICAgICAgICAgcmVzLmRvbmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGFzdENhbGwpIHtcbiAgICAgICAgcmVzLmRvbmUodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoKCkgPT5cbiAgICBtb2RlbC5kb1N0cmVhbSh7XG4gICAgICBtb2RlOiB7XG4gICAgICAgIHR5cGU6ICdyZWd1bGFyJyxcbiAgICAgICAgLi4ucHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7IHRvb2xzLCB0b29sQ2hvaWNlIH0pLFxuICAgICAgfSxcbiAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICB9KSxcbiAgKTtcblxuICBjb25zdCBbc3RyZWFtLCBmb3JrZWRTdHJlYW1dID0gcmVzdWx0LnN0cmVhbS50ZWUoKTtcblxuICAoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDb25zdW1lIHRoZSBmb3JrZWQgc3RyZWFtIGFzeW5jaG9ub3VzbHkuXG5cbiAgICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgICBsZXQgaGFzVG9vbENhbGwgPSBmYWxzZTtcblxuICAgICAgY29uc3QgcmVhZGVyID0gZm9ya2VkU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuXG4gICAgICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3RleHQtZGVsdGEnOiB7XG4gICAgICAgICAgICBjb250ZW50ICs9IHZhbHVlLnRleHREZWx0YTtcbiAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgW3sgY29udGVudCwgZG9uZTogZmFsc2UsIGRlbHRhOiB2YWx1ZS50ZXh0RGVsdGEgfV0sXG4gICAgICAgICAgICAgIHRleHRSZW5kZXIsXG4gICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3Rvb2wtY2FsbC1kZWx0YSc6IHtcbiAgICAgICAgICAgIGhhc1Rvb2xDYWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3Rvb2wtY2FsbCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gdmFsdWUudG9vbE5hbWUgYXMga2V5b2YgVE9PTFMgJiBzdHJpbmc7XG5cbiAgICAgICAgICAgIGlmICghdG9vbHMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiB0b29sTmFtZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdG9vbCA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgIGlmICghdG9vbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFzVG9vbENhbGwgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgdGV4dDogdmFsdWUuYXJncyxcbiAgICAgICAgICAgICAgc2NoZW1hOiB0b29sLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICB0b29sQXJnczogdmFsdWUuYXJncyxcbiAgICAgICAgICAgICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYW5kbGVSZW5kZXIoXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHZhbHVlLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgdG9vbC5nZW5lcmF0ZSxcbiAgICAgICAgICAgICAgdWksXG4gICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlcnJvcic6IHtcbiAgICAgICAgICAgIHRocm93IHZhbHVlLmVycm9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ZpbmlzaCc6IHtcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1Rvb2xDYWxsKSB7XG4gICAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlUmVuZGVyKFt7IGNvbnRlbnQsIGRvbmU6IHRydWUgfV0sIHRleHRSZW5kZXIsIHVpLCB0cnVlKTtcbiAgICAgICAgYXdhaXQgZmluaXNoZWQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIER1cmluZyB0aGUgc3RyZWFtIHJlbmRlcmluZywgd2UgZG9uJ3Qgd2FudCB0byB0aHJvdyB0aGUgZXJyb3IgdG8gdGhlXG4gICAgICAvLyBwYXJlbnQgc2NvcGUgYnV0IG9ubHkgbGV0IHRoZSBSZWFjdCdzIGVycm9yIGJvdW5kYXJ5IHRvIGNhdGNoIGl0LlxuICAgICAgdWkuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnJlc3VsdCxcbiAgICBzdHJlYW0sXG4gICAgdmFsdWU6IHVpLnZhbHVlLFxuICB9O1xufVxuIiwiLy8gVGhpcyBmaWxlIHByb3ZpZGVzIHRoZSBBSSBjb250ZXh0IHRvIGFsbCBBSSBBY3Rpb25zIHZpYSBBc3luY0xvY2FsU3RvcmFnZS5cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgSW50ZXJuYWxBSVByb3ZpZGVyIH0gZnJvbSAnLi9yc2Mtc2hhcmVkLm1qcyc7XG5pbXBvcnQge1xuICB3aXRoQUlTdGF0ZSxcbiAgZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSxcbiAgc2VhbE11dGFibGVBSVN0YXRlLFxufSBmcm9tICcuL2FpLXN0YXRlJztcbmltcG9ydCB0eXBlIHtcbiAgU2VydmVyV3JhcHBlZEFjdGlvbnMsXG4gIEFJQWN0aW9uLFxuICBBSUFjdGlvbnMsXG4gIEFJUHJvdmlkZXIsXG4gIEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zLFxuICBPblNldEFJU3RhdGUsXG4gIE9uR2V0VUlTdGF0ZSxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmFzeW5jIGZ1bmN0aW9uIGlubmVyQWN0aW9uPFQ+KFxuICB7XG4gICAgYWN0aW9uLFxuICAgIG9wdGlvbnMsXG4gIH06IHsgYWN0aW9uOiBBSUFjdGlvbjsgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMgfSxcbiAgc3RhdGU6IFQsXG4gIC4uLmFyZ3M6IHVua25vd25bXVxuKSB7XG4gICd1c2Ugc2VydmVyJztcbiAgcmV0dXJuIGF3YWl0IHdpdGhBSVN0YXRlKFxuICAgIHtcbiAgICAgIHN0YXRlLFxuICAgICAgb3B0aW9ucyxcbiAgICB9LFxuICAgIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFjdGlvbiguLi5hcmdzKTtcbiAgICAgIHNlYWxNdXRhYmxlQUlTdGF0ZSgpO1xuICAgICAgcmV0dXJuIFtnZXRBSVN0YXRlRGVsdGFQcm9taXNlKCkgYXMgUHJvbWlzZTxUPiwgcmVzdWx0XTtcbiAgICB9LFxuICApO1xufVxuXG5mdW5jdGlvbiB3cmFwQWN0aW9uPFQgPSB1bmtub3duPihcbiAgYWN0aW9uOiBBSUFjdGlvbixcbiAgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMsXG4pIHtcbiAgcmV0dXJuIGlubmVyQWN0aW9uLmJpbmQobnVsbCwgeyBhY3Rpb24sIG9wdGlvbnMgfSkgYXMgQUlBY3Rpb248VD47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBSTxcbiAgQUlTdGF0ZSA9IGFueSxcbiAgVUlTdGF0ZSA9IGFueSxcbiAgQWN0aW9ucyBleHRlbmRzIEFJQWN0aW9ucyA9IHt9LFxuPih7XG4gIGFjdGlvbnMsXG4gIGluaXRpYWxBSVN0YXRlLFxuICBpbml0aWFsVUlTdGF0ZSxcblxuICBvblNldEFJU3RhdGUsXG4gIG9uR2V0VUlTdGF0ZSxcbn06IHtcbiAgYWN0aW9uczogQWN0aW9ucztcbiAgaW5pdGlhbEFJU3RhdGU/OiBBSVN0YXRlO1xuICBpbml0aWFsVUlTdGF0ZT86IFVJU3RhdGU7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBBSSBzdGF0ZSBpcyB1cGRhdGVkIGJ5IGFuIEFjdGlvbi5cbiAgICogWW91IGNhbiB1c2UgdGhpcyB0byBwZXJzaXN0IHRoZSBBSSBzdGF0ZSB0byBhIGRhdGFiYXNlLCBvciB0byBzZW5kIGl0IHRvIGFcbiAgICogbG9nZ2luZyBzZXJ2aWNlLlxuICAgKi9cbiAgb25TZXRBSVN0YXRlPzogT25TZXRBSVN0YXRlPEFJU3RhdGU+O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmV0cmlldmUgdGhlIFVJIHN0YXRlIGJhc2VkIG9uIHRoZSBBSSBzdGF0ZS5cbiAgICogRm9yIGV4YW1wbGUsIHRvIHJlbmRlciB0aGUgaW5pdGlhbCBVSSBzdGF0ZSBiYXNlZCBvbiBhIGdpdmVuIEFJIHN0YXRlLCBvclxuICAgKiB0byBzeW5jIHRoZSBVSSBzdGF0ZSB3aGVuIHRoZSBhcHBsaWNhdGlvbiBpcyBhbHJlYWR5IGxvYWRlZC5cbiAgICpcbiAgICogSWYgcmV0dXJuaW5nIGB1bmRlZmluZWRgLCB0aGUgY2xpZW50IHNpZGUgVUkgc3RhdGUgd2lsbCBub3QgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIGFubm90YXRlZCB3aXRoIHRoZSBgXCJ1c2Ugc2VydmVyXCJgIGRpcmVjdGl2ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIG9uR2V0VUlTdGF0ZTogYXN5bmMgKCkgPT4ge1xuICAgKiAgICd1c2Ugc2VydmVyJztcbiAgICpcbiAgICogICBjb25zdCBjdXJyZW50QUlTdGF0ZSA9IGdldEFJU3RhdGUoKTtcbiAgICogICBjb25zdCBleHRlcm5hbEFJU3RhdGUgPSBhd2FpdCBsb2FkQUlTdGF0ZUZyb21EYXRhYmFzZSgpO1xuICAgKlxuICAgKiAgIGlmIChjdXJyZW50QUlTdGF0ZSA9PT0gZXh0ZXJuYWxBSVN0YXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgKlxuICAgKiAgIC8vIFVwZGF0ZSBjdXJyZW50IEFJIHN0YXRlIGFuZCByZXR1cm4gdGhlIG5ldyBVSSBzdGF0ZVxuICAgKiAgIGNvbnN0IHN0YXRlID0gZ2V0TXV0YWJsZUFJU3RhdGUoKVxuICAgKiAgIHN0YXRlLmRvbmUoZXh0ZXJuYWxBSVN0YXRlKVxuICAgKlxuICAgKiAgIHJldHVybiA8ZGl2Pi4uLjwvZGl2PjtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIG9uR2V0VUlTdGF0ZT86IE9uR2V0VUlTdGF0ZTxVSVN0YXRlPjtcbn0pIHtcbiAgLy8gV3JhcCBhbGwgYWN0aW9ucyB3aXRoIG91ciBIb0MuXG4gIGNvbnN0IHdyYXBwZWRBY3Rpb25zOiBTZXJ2ZXJXcmFwcGVkQWN0aW9ucyA9IHt9O1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gYWN0aW9ucykge1xuICAgIHdyYXBwZWRBY3Rpb25zW25hbWVdID0gd3JhcEFjdGlvbihhY3Rpb25zW25hbWVdLCB7XG4gICAgICBvblNldEFJU3RhdGUsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCB3cmFwcGVkU3luY1VJU3RhdGUgPSBvbkdldFVJU3RhdGVcbiAgICA/IHdyYXBBY3Rpb24ob25HZXRVSVN0YXRlLCB7fSlcbiAgICA6IHVuZGVmaW5lZDtcblxuICBjb25zdCBBSTogQUlQcm92aWRlcjxBSVN0YXRlLCBVSVN0YXRlLCBBY3Rpb25zPiA9IGFzeW5jIHByb3BzID0+IHtcbiAgICBpZiAoJ3VzZVN0YXRlJyBpbiBSZWFjdCkge1xuICAgICAgLy8gVGhpcyBmaWxlIG11c3QgYmUgcnVubmluZyBvbiB0aGUgUmVhY3QgU2VydmVyIGxheWVyLlxuICAgICAgLy8gSWRlYWxseSB3ZSBzaG91bGQgYmUgdXNpbmcgYGltcG9ydCBcInNlcnZlci1vbmx5XCJgIGhlcmUgYnV0IHdlIGNhbiBoYXZlIGFcbiAgICAgIC8vIG1vcmUgY3VzdG9taXplZCBlcnJvciBtZXNzYWdlIHdpdGggdGhpcyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoaXMgY29tcG9uZW50IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIFNlcnZlciBDb21wb25lbnRzLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB1aVN0YXRlID0gcHJvcHMuaW5pdGlhbFVJU3RhdGUgPz8gaW5pdGlhbFVJU3RhdGU7XG4gICAgbGV0IGFpU3RhdGUgPSBwcm9wcy5pbml0aWFsQUlTdGF0ZSA/PyBpbml0aWFsQUlTdGF0ZTtcbiAgICBsZXQgYWlTdGF0ZURlbHRhID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHdyYXBwZWRTeW5jVUlTdGF0ZSkge1xuICAgICAgY29uc3QgW25ld0FJU3RhdGVEZWx0YSwgbmV3VUlTdGF0ZV0gPSBhd2FpdCB3cmFwcGVkU3luY1VJU3RhdGUoYWlTdGF0ZSk7XG4gICAgICBpZiAobmV3VUlTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFpU3RhdGVEZWx0YSA9IG5ld0FJU3RhdGVEZWx0YTtcbiAgICAgICAgdWlTdGF0ZSA9IG5ld1VJU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxJbnRlcm5hbEFJUHJvdmlkZXJcbiAgICAgICAgd3JhcHBlZEFjdGlvbnM9e3dyYXBwZWRBY3Rpb25zfVxuICAgICAgICB3cmFwcGVkU3luY1VJU3RhdGU9e3dyYXBwZWRTeW5jVUlTdGF0ZX1cbiAgICAgICAgaW5pdGlhbFVJU3RhdGU9e3VpU3RhdGV9XG4gICAgICAgIGluaXRpYWxBSVN0YXRlPXthaVN0YXRlfVxuICAgICAgICBpbml0aWFsQUlTdGF0ZVBhdGNoPXthaVN0YXRlRGVsdGF9XG4gICAgICA+XG4gICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICAgIDwvSW50ZXJuYWxBSVByb3ZpZGVyPlxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIEFJO1xufVxuIl0sIm5hbWVzIjpbIkFzeW5jTG9jYWxTdG9yYWdlIiwianNvbmRpZmZwYXRjaCIsImNyZWF0ZVJlc29sdmFibGVQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzIiwicmVqIiwiaXNGdW5jdGlvbiIsIngiLCJjb25zdW1lU3RyZWFtIiwic3RyZWFtIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiZG9uZSIsInJlYWQiLCJhc3luY0FJU3RhdGVTdG9yYWdlIiwiZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyIsIm1lc3NhZ2UiLCJzdG9yZSIsImdldFN0b3JlIiwiRXJyb3IiLCJ3aXRoQUlTdGF0ZSIsInN0YXRlIiwib3B0aW9ucyIsImZuIiwicnVuIiwiY3VycmVudFN0YXRlIiwib3JpZ2luYWxTdGF0ZSIsInNlYWxlZCIsImdldEFJU3RhdGVEZWx0YVByb21pc2UiLCJtdXRhdGlvbkRlbHRhUHJvbWlzZSIsInNlYWxNdXRhYmxlQUlTdGF0ZSIsImdldEFJU3RhdGUiLCJhcmdzIiwibGVuZ3RoIiwia2V5IiwiU3RyaW5nIiwiZ2V0TXV0YWJsZUFJU3RhdGUiLCJtdXRhdGlvbkRlbHRhUmVzb2x2ZSIsImRvVXBkYXRlIiwibmV3U3RhdGUiLCJfYSIsIl9iIiwib25TZXRBSVN0YXRlIiwiY2FsbCIsIm11dGFibGVTdGF0ZSIsImdldCIsInVwZGF0ZSIsIm5ld0FJU3RhdGUiLCJkb25lQXJncyIsImRlbHRhIiwiZGlmZiIsImlzVmFsaWRFbGVtZW50Iiwiem9kVG9Kc29uU2NoZW1hIiwiQVBJQ2FsbEVycm9yIiwiUmV0cnlFcnJvciIsImdldEVycm9yTWVzc2FnZSIsImlzQWJvcnRFcnJvciIsImRlbGF5IiwiZGVsYXlJbk1zIiwic2V0VGltZW91dCIsInJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsIm1heFJldHJpZXMiLCJpbml0aWFsRGVsYXlJbk1zIiwiYmFja29mZkZhY3RvciIsImYiLCJfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwiZXJyb3JzIiwiZXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJuZXdFcnJvcnMiLCJ0cnlOdW1iZXIiLCJyZWFzb24iLCJpc0FQSUNhbGxFcnJvciIsImlzUmV0cnlhYmxlIiwibWltZVR5cGVTaWduYXR1cmVzIiwibWltZVR5cGUiLCJieXRlcyIsImRldGVjdEltYWdlTWltZVR5cGUiLCJpbWFnZSIsImV2ZXJ5IiwiYnl0ZSIsImluZGV4IiwiSW52YWxpZERhdGFDb250ZW50RXJyb3IiLCJjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IiwiY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCIsImNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheSIsImNvbnRlbnQiLCJVaW50OEFycmF5IiwiY2F1c2UiLCJBcnJheUJ1ZmZlciIsIkludmFsaWRNZXNzYWdlUm9sZUVycm9yIiwiY29uc3RydWN0b3IiLCJyb2xlIiwibmFtZSIsImlzSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IiLCJ0b0pTT04iLCJzdGFjayIsImNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQiLCJwcm9tcHQiLCJsYW5ndWFnZU1vZGVsTWVzc2FnZXMiLCJzeXN0ZW0iLCJwdXNoIiwicHJvbXB0VHlwZSIsInR5cGUiLCJ0ZXh0IiwibWVzc2FnZXMiLCJtYXAiLCJjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZSIsIl9leGhhdXN0aXZlQ2hlY2siLCJwYXJ0IiwiVVJMIiwidXJsIiwicHJvdG9jb2wiLCJoZWFkZXIiLCJiYXNlNjRDb250ZW50Iiwic3BsaXQiLCJfaWdub3JlZCIsImltYWdlVWludDgiLCJmaWx0ZXIiLCJJbnZhbGlkUHJvbXB0RXJyb3IiLCJnZXRWYWxpZGF0ZWRQcm9tcHQiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsInByZXBhcmVDYWxsU2V0dGluZ3MiLCJtYXhUb2tlbnMiLCJ0ZW1wZXJhdHVyZSIsInRvcFAiLCJwcmVzZW5jZVBlbmFsdHkiLCJmcmVxdWVuY3lQZW5hbHR5Iiwic2VlZCIsIk51bWJlciIsImlzSW50ZWdlciIsInBhcmFtZXRlciIsInZhbHVlIiwiY29udmVydFpvZFRvSlNPTlNjaGVtYSIsInpvZFNjaGVtYSIsImlzTm9uRW1wdHlPYmplY3QiLCJvYmplY3QiLCJPYmplY3QiLCJrZXlzIiwicHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSIsInRvb2xzIiwidG9vbENob2ljZSIsImVudHJpZXMiLCJ0b29sIiwiZGVzY3JpcHRpb24iLCJwYXJhbWV0ZXJzIiwidG9vbE5hbWUiLCJjcmVhdGVQYXJzZXIiLCJjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyIiwiY3VzdG9tUGFyc2VyIiwidGV4dERlY29kZXIiLCJUZXh0RGVjb2RlciIsImV2ZW50U291cmNlUGFyc2VyIiwiVHJhbnNmb3JtU3RyZWFtIiwic3RhcnQiLCJjb250cm9sbGVyIiwiZXZlbnQiLCJkYXRhIiwidGVybWluYXRlIiwicGFyc2VkTWVzc2FnZSIsImVucXVldWUiLCJ0cmFuc2Zvcm0iLCJjaHVuayIsImZlZWQiLCJkZWNvZGUiLCJjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lciIsImNiIiwidGV4dEVuY29kZXIiLCJUZXh0RW5jb2RlciIsImFnZ3JlZ2F0ZWRSZXNwb25zZSIsImNhbGxiYWNrcyIsIm9uU3RhcnQiLCJlbmNvZGUiLCJvblRva2VuIiwib25UZXh0IiwiZmx1c2giLCJpc09wZW5BSUNhbGxiYWNrcyIsImlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIiwib25Db21wbGV0aW9uIiwib25GaW5hbCIsInRyaW1TdGFydE9mU3RyZWFtSGVscGVyIiwiaXNTdHJlYW1TdGFydCIsInRyaW1TdGFydCIsIkFJU3RyZWFtIiwicmVzcG9uc2UiLCJvayIsImJvZHkiLCJSZWFkYWJsZVN0cmVhbSIsImVycm9yVGV4dCIsInJlc3BvbnNlQm9keVN0cmVhbSIsImNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0iLCJwaXBlVGhyb3VnaCIsImNsb3NlIiwicmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwicHVsbCIsIm5leHQiLCJjYW5jZWwiLCJyZXR1cm4iLCJmb3JtYXRTdHJlYW1QYXJ0IiwiY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyIiwiZW5jb2RlciIsImRlY29kZXIiLCJjcmVhdGVDaHVua0RlY29kZXIiLCJwYXJzZU9wZW5BSVN0cmVhbSIsImV4dHJhY3QiLCJjaHVua1RvVGV4dCIsIkpTT04iLCJwYXJzZSIsInN0cmVhbWFibGUiLCJpZCIsImNyZWF0ZWQiLCJnZXREYXRlIiwibW9kZWwiLCJjaG9pY2VzIiwiY2hvaWNlIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfZyIsImZ1bmN0aW9uX2NhbGwiLCJmdW5jdGlvbkNhbGwiLCJ0b29sX2NhbGxzIiwidG9vbENhbGxzIiwidG9vbENhbGwiLCJmdW5jdGlvbiIsImZpbmlzaF9yZWFzb24iLCJmaW5pc2hSZWFzb24iLCJ0cmltU3RhcnRPZlN0cmVhbSIsImlzRnVuY3Rpb25TdHJlYW1pbmdJbiIsImpzb24iLCJfaCIsIl9pIiwiX2oiLCJfayIsIl9sIiwiX20iLCJfbiIsIl9vIiwiX3AiLCJfcSIsIl9yIiwiaXNDaGF0Q29tcGxldGlvbkNodW5rIiwiaXNUZXh0IiwiYXJndW1lbnRzIiwiY2xlYW51cEFyZ3VtZW50cyIsImlzQ29tcGxldGlvbiIsImFyZ3VtZW50Q2h1bmsiLCJlc2NhcGVkUGFydGlhbEpzb24iLCJyZXBsYWNlIiwiX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCIsIk9wZW5BSVN0cmVhbSIsImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCIsImV4cGVyaW1lbnRhbF9vblRvb2xDYWxsIiwiZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIiLCJjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImlzRmlyc3RDaHVuayIsImFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSIsImZ1bmN0aW9uQ2FsbE1lc3NhZ2VzIiwic2hvdWxkSGFuZGxlQXNGdW5jdGlvbiIsInN0YXJ0c1dpdGgiLCJwYXlsb2FkIiwibmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJmdW5jdGlvblJlc3BvbnNlIiwiY29uc29sZSIsIndhcm4iLCJhcmd1bWVudHNQYXlsb2FkIiwicmVzdWx0Iiwic3RyaW5naWZ5IiwiZnVuYyIsInJlc3BvbnNlSW5kZXgiLCJ0b29sX2NhbGxfaWQiLCJmdW5jdGlvbl9uYW1lIiwidG9vbF9jYWxsX3Jlc3VsdCIsInRjIiwiZSIsImZpbHRlcmVkQ2FsbGJhY2tzIiwib3BlbkFJU3RyZWFtIiwiU1RSRUFNQUJMRV9WQUxVRV9UWVBFIiwiZm9yIiwiREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUiLCJJbnRlcm5hbFN0cmVhbWFibGVVSUNsaWVudCIsIkZyYWdtZW50IiwianN4IiwianN4cyIsImNyZWF0ZVN0cmVhbWFibGVVSSIsImluaXRpYWxWYWx1ZSIsImlubmVyU3RyZWFtYWJsZSIsImNyZWF0ZVN0cmVhbWFibGVWYWx1ZSIsImNsb3NlZCIsImFzc2VydFN0cmVhbSIsIm1ldGhvZCIsIndhcm5pbmdUaW1lb3V0Iiwid2FyblVuY2xvc2VkU3RyZWFtIiwicHJvY2VzcyIsImNsZWFyVGltZW91dCIsInMiLCJhcHBlbmQiLCJTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0siLCJpc1JlYWRhYmxlU3RyZWFtIiwibG9ja2VkIiwiY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbCIsInN0cmVhbWFibGVWYWx1ZSIsInJlc29sdmFibGUiLCJjdXJyZW50VmFsdWUiLCJjdXJyZW50RXJyb3IiLCJjdXJyZW50UHJvbWlzZSIsImN1cnJlbnRQYXRjaFZhbHVlIiwiY3JlYXRlV3JhcHBlZCIsImluaXRpYWxDaHVuayIsImluaXQiLCJjdXJyIiwidXBkYXRlVmFsdWVTdGF0ZXMiLCJzbGljZSIsInJlc29sdmVQcmV2aW91cyIsImNoaWxkcmVuIiwicmVuZGVyIiwidWkiLCJpbml0aWFsIiwiZnVuY3Rpb25zIiwiZmluaXNoZWQiLCJoYW5kbGVSZW5kZXIiLCJyZW5kZXJlciIsInRoZW4iLCJub2RlIiwiaXRlcmF0b3IiLCJoYXNGdW5jdGlvbiIsInByb3ZpZGVyIiwiY2hhdCIsImNvbXBsZXRpb25zIiwiY3JlYXRlIiwiZnVuY3Rpb25DYWxsUGF5bG9hZCIsInRvb2xDYWxsUGF5bG9hZCIsIkludmFsaWRUb29sQXJndW1lbnRzRXJyb3IiLCJOb1N1Y2hUb29sRXJyb3IiLCJzYWZlUGFyc2VKU09OIiwiZGVmYXVsdFRleHRSZW5kZXJlciIsInN0cmVhbVVJIiwiYWJvcnRTaWduYWwiLCJzZXR0aW5ncyIsInRleHRSZW5kZXIiLCJsYXN0Q2FsbCIsInJldHJ5IiwidmFsaWRhdGVkUHJvbXB0IiwiZG9TdHJlYW0iLCJtb2RlIiwiaW5wdXRGb3JtYXQiLCJmb3JrZWRTdHJlYW0iLCJ0ZWUiLCJoYXNUb29sQ2FsbCIsInRleHREZWx0YSIsImF2YWlsYWJsZVRvb2xzIiwicGFyc2VSZXN1bHQiLCJzY2hlbWEiLCJzdWNjZXNzIiwidG9vbEFyZ3MiLCJ0b29sQ2FsbElkIiwiZ2VuZXJhdGUiLCJSZWFjdCIsIkludGVybmFsQUlQcm92aWRlciIsImlubmVyQWN0aW9uIiwiYWN0aW9uIiwid3JhcEFjdGlvbiIsImJpbmQiLCJjcmVhdGVBSSIsImFjdGlvbnMiLCJpbml0aWFsQUlTdGF0ZSIsImluaXRpYWxVSVN0YXRlIiwib25HZXRVSVN0YXRlIiwid3JhcHBlZEFjdGlvbnMiLCJ3cmFwcGVkU3luY1VJU3RhdGUiLCJBSSIsInByb3BzIiwidWlTdGF0ZSIsImFpU3RhdGUiLCJhaVN0YXRlRGVsdGEiLCJuZXdBSVN0YXRlRGVsdGEiLCJuZXdVSVN0YXRlIiwiaW5pdGlhbEFJU3RhdGVQYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/rsc/dist/rsc-server.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalAIProvider: () => (/* binding */ e0),
/* harmony export */   InternalStreamableUIClient: () => (/* binding */ e1),
/* harmony export */   readStreamableValue: () => (/* binding */ e2),
/* harmony export */   useAIState: () => (/* binding */ e3),
/* harmony export */   useActions: () => (/* binding */ e4),
/* harmony export */   useStreamableValue: () => (/* binding */ e5),
/* harmony export */   useSyncUIState: () => (/* binding */ e6),
/* harmony export */   useUIState: () => (/* binding */ e7)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/ryousuke/like_perplexityai/web/node_modules/ai/rsc/dist/rsc-shared.mjs`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/ryousuke/like_perplexityai/web/node_modules/ai/rsc/dist/rsc-shared.mjs#InternalAIProvider`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/ryousuke/like_perplexityai/web/node_modules/ai/rsc/dist/rsc-shared.mjs#InternalStreamableUIClient`);

const e2 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/ryousuke/like_perplexityai/web/node_modules/ai/rsc/dist/rsc-shared.mjs#readStreamableValue`);

const e3 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/ryousuke/like_perplexityai/web/node_modules/ai/rsc/dist/rsc-shared.mjs#useAIState`);

const e4 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/ryousuke/like_perplexityai/web/node_modules/ai/rsc/dist/rsc-shared.mjs#useActions`);

const e5 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/ryousuke/like_perplexityai/web/node_modules/ai/rsc/dist/rsc-shared.mjs#useStreamableValue`);

const e6 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/ryousuke/like_perplexityai/web/node_modules/ai/rsc/dist/rsc-shared.mjs#useSyncUIState`);

const e7 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/ryousuke/like_perplexityai/web/node_modules/ai/rsc/dist/rsc-shared.mjs#useUIState`);


/***/ })

};
;